{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/topology-aware-routing-kubernetes/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p><strong>How Topology Aware Routing Can Reduce Costs and Improve Network Performance üöÄ</strong></p>\n</blockquote>\n<h2 id=\"-introduction\" style=\"position:relative;\"><a href=\"#-introduction\" aria-label=\" introduction permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>üîñ Introduction</h2>\n<p><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 54.70588235294118%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABr0lEQVR42o2S227TQBRF+8H8CuITeIRf4KG8I4RQUSu7IfGl8TX22PF17Ngzi7EbIQIpqqytsUfb65wzs2+0UmitL3Qye4PSDLNaNc6a0Xy307NXnaWv6OYCaB6MDnLG7RRihlxBatZo1PjtvPoWj34NsBuM2aximPF6zdefT9x+37DZhwRVRyLVCju2it4UXd6V+guo1GKCth/5cJvRdiPSmNwBLHfDvfUFe3uHk2a4cnEqPn0bud/K60B9BkopyXJB17Z4YYwVJLhBwFMSs4szdkmO7e9p294UN+dpjmSer428HLCBFqKgKATTNFEdS0ohyA8Zwuzn2QGRZZRFwTBI8vxAHIUGOF0HLhDbtrEsi7JJyGqHvMhwXI+d46xK0hRRhxStj+d5PD5uOJ1O63Tqj3v4PXLTNFRVZeKgOFalGb2mqWvTmaCujvRdS1UWSNNhWZZEUXQBeiE2pto8s49itmHKxnf54T5gOT7bIMb29si+/6erF4HPN66J+gnX/BfIkTfv3vP242fCCdxmWmOl9StzqM6hTU3G/F4Rj3D3JHhIjibYpkA//xe2AH8BO5FQ9eUzMXAAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"alt text\" title=\"\" src=\"/static/9e0ee14cda75263528143430f4303c82/c5bb3/image.png\" srcset=\"/static/9e0ee14cda75263528143430f4303c82/04472/image.png 170w,\n/static/9e0ee14cda75263528143430f4303c82/9f933/image.png 340w,\n/static/9e0ee14cda75263528143430f4303c82/c5bb3/image.png 680w,\n/static/9e0ee14cda75263528143430f4303c82/b12f7/image.png 1020w,\n/static/9e0ee14cda75263528143430f4303c82/b5a09/image.png 1360w,\n/static/9e0ee14cda75263528143430f4303c82/b5c8e/image.png 2194w\" sizes=\"(max-width: 680px) 100vw, 680px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n          </p>\n<p>As Kubernetes clusters are increasingly deployed in multi-zone environments, it becomes important to keep network traffic within the zone where it originated. <a href=\"https://kubernetes.io/docs/concepts/services-networking/topology-aware-routing/\" target=\"_blank\" rel=\"noopener noreferrer\">Topology Aware Routing</a> (TAR) is a feature in Kubernetes that adjusts routing behavior to prefer keeping traffic in the zone it originated from.</p>\n<p>This can help reduce costs or improve network performance by minimizing inter-zone traffic and ensuring that traffic reaches its destination with minimal delay.</p>\n<p>In this blog post, we will learn about the concept of Kubernetes topology aware routing and discuss its benefits in terms of reducing latency and optimizing network traffic flow.</p>\n<p>We will also show you how to enable Topology Aware Routing for a Service and minimize the performance impact of overlay networking. In this blog post, we will refer to Topology Aware Routing as TAR.</p>\n<div class=\"note\">\n    <p><strong>üîµ Note:</strong></p>\n    <p>Prior to Kubernetes 1.27, this feature was known as Topology Aware Hints.</p>\n</div>\n<br>\n<p><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 56.470588235294116%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAHEaGJJCv/EABYQAQEBAAAAAAAAAAAAAAAAAAEAEP/aAAgBAQABBQIMYmb/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAZEAADAAMAAAAAAAAAAAAAAAAAAREhMVH/2gAIAQEAAT8hoh8Io7HybH//2gAMAwEAAgADAAAAEL/v/8QAGBEAAgMAAAAAAAAAAAAAAAAAAAERIUH/2gAIAQMBAT8Q2BKj/8QAFhEBAQEAAAAAAAAAAAAAAAAAABFB/9oACAECAQE/EMV//8QAGRABAQEBAQEAAAAAAAAAAAAAAQARITFh/9oACAEBAAE/EMHQuXg58iWBkjBfJDYyVrf/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"topology-aware-routing-cover\" title=\"\" src=\"/static/22d537a84aef2176b19b1d7ab3202478/7bf67/topology-aware-routing.jpg\" srcset=\"/static/22d537a84aef2176b19b1d7ab3202478/651be/topology-aware-routing.jpg 170w,\n/static/22d537a84aef2176b19b1d7ab3202478/d30a3/topology-aware-routing.jpg 340w,\n/static/22d537a84aef2176b19b1d7ab3202478/7bf67/topology-aware-routing.jpg 680w,\n/static/22d537a84aef2176b19b1d7ab3202478/990cb/topology-aware-routing.jpg 1020w,\n/static/22d537a84aef2176b19b1d7ab3202478/e5166/topology-aware-routing.jpg 1200w\" sizes=\"(max-width: 680px) 100vw, 680px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n          </p>\n<h2 id=\"-impact-of-tar-on-network-traffic-in-amazoneks\" style=\"position:relative;\"><a href=\"#-impact-of-tar-on-network-traffic-in-amazoneks\" aria-label=\" impact of tar on network traffic in amazoneks permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>üåê Impact of TAR on Network Traffic in Amazon¬†EKS</h2>\n<p>A best practice for architecting resilient systems in AWS is to leverage multiple Availability Zones (AZs). AWS Regions are composed of multiple AZs designed to be independent of each other and are separated by a meaningful physical distance to avoid correlated failure scenarios.</p>\n<p>AWS EKS makes it possible for customers to run their mission-critical workloads across multiple distinct AZs, providing increased availability by combining Amazon's global infrastructure with Kubernetes constructs such as pod topology spread constraints. However, when architecting workloads in this manner, there are considerations in terms of both latency and cost to consider. Pods within the same Amazon EKS cluster can easily communicate using a Kubernetes Cluster IP Service, which routes traffic to its associated pods even if they are in different AZs.</p>\n<p>Although this is a convenient way to take advantage of multiple AZs, some customers may want to bias traffic routing to pods in the same AZ as the originator. Keeping traffic in the same AZ benefits latency-sensitive workloads for low latency and can reduce inter-AZ data transfer costs.</p>\n<p>TAR is a feature that reached beta status in Kubernetes version 1.23 and became available in Amazon EKS version 1.24. It's intended to provide a mechanism that attempts to keep traffic closer to its origin within the same AZ or in another location.</p>\n<h2 id=\"Ô∏è-services-in-kubernetes\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-services-in-kubernetes\" aria-label=\"Ô∏è services in kubernetes permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>üõ†Ô∏è Services in Kubernetes</h2>\n<p>Let's begin by explaining how a Kubernetes Service operates before exploring TAR.</p>\n<p>When you create a Service, you define a selector to target specific pods. Kubernetes generates an Endpoints object, which maintains the IP addresses of the relevant pods. Subsequently, the Kubernetes controller assigns a Cluster IP to the Service‚Ää-‚Ääa virtual IP accessible only within the worker nodes of the Kubernetes cluster.</p>\n<p>The kube-proxy DaemonSet instance, running on each node, establishes a set of <a href=\"https://kubernetes.io/docs/reference/networking/virtual-ips/#proxy-modes\" target=\"_blank\" rel=\"noopener noreferrer\">iptables rules</a> (or IP Virtual Server (IPVS) virtual servers, if enabled). When traffic is directed at the Cluster IP (or enters the cluster via NodePort), either iptables or IPVS routes the packet to a pod based on its load balancing algorithm.</p>\n<p>By default, kube-proxy adds all pods from an Endpoints object to each node's iptables or IPVS, without considering factors like the availability zones (AZs) where the pods reside or the originating traffic zone.</p>\n<p>Consequently, packets are routed indiscriminately across AZs, potentially introducing latency and incurring inter-AZ data traffic costs.</p>\n<h2 id=\"-understanding-tar-functionality\" style=\"position:relative;\"><a href=\"#-understanding-tar-functionality\" aria-label=\" understanding tar functionality permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>üîÑ Understanding TAR Functionality</h2>\n<p>TAR offers a different way to route traffic by sending some endpoints to kube-proxy. It relies on the EndpointSlices controller, which is more flexible than the Endpoints controller. Endpoints in the Endpoints controller only have pod IP addresses and ports, but EndpointSlices can include hints. Hints are extra labels on each endpoint.</p>\n<p>TAR adds a hint about which zone the endpoint is in. When a hint is added, kube-proxy filters the endpoints based on these hints. Usually, it picks endpoints in the same zone. When traffic reaches kube-proxy, it is directed only to pods in the same zone, avoiding traffic costs.</p>\n<h3 id=\"hands-on-example\" style=\"position:relative;\"><a href=\"#hands-on-example\" aria-label=\"hands on example permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Hands-on example</h3>\n<p>In this walkthrough, you'll deploy an EKS cluster using Terraform. You can design your infrastructures as templates and use Terraform to provision, manage, and destroy them. Besides the cluster itself, Terraform also deploys the AWS Distro for <a href=\"https://aws-otel.github.io/\" target=\"_blank\" rel=\"noopener noreferrer\">OpenTelemetry (ADOT) Operator</a> via its <a href=\"https://github.com/aws-ia/terraform-aws-eks-blueprints-addons\" target=\"_blank\" rel=\"noopener noreferrer\">EKS Blueprints add-ons</a>. The ADOT Operator enables a simplified experience for instrumenting your applications running on Amazon EKS to capture metrics and tracing data.</p>\n<p>We'll use the ADOT Operator and AWS X-Ray to visualize the requests between workloads running on the Amazon EKS cluster. After the EKS cluster and its related infrastructure are created, we deploy the containers sample application, which shows traffic between separate front-end and back-end components. This allows us to explore how different configurations of the EKS worker nodes and pods affect TAR.</p>\n<p><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 41.76470588235294%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABbUlEQVR42m1Sy04DMQzki/kUfoB/4MSBA0c4IYEEQqpAQBF0u9Cm227edpLBSbU8JCKtHK+t8cw4B/jn5FLgIsF6D04JRfLfp+bMjNEY6EBQ210ZtUVKaXXw3ZQLsnwpZxBFbEaHq+cBxgdEyfeDpE8iM0nd4/59hNIGNsQ2kph/AKcjP2GshQsRyyG0qCUvJTewLAOddxiMR7+TunOVWZMQK6CWCZEsXu4sLk822A0OgQKUcZgtt8IwIgQHJYyOzhQeOgsmh9ERHnuDxVrhqd+VxcACKZK7rhcGG1ycdjg6vEG/2MJHJywDZl1lSsLCik8Gx+cd5v2IGGyT/Lr2sFZjqXRZmSzsBVDoNhkpZWlkYUsIMWJwAXM1QouHVmRJM0gGJfHPhwCS/rX2mH8q2Eh7yfSPh3Wr1ZdRJF+/6OZhBZg2XWOMAR8bg9s30+7Eew//LKX2T6+jbpp5z5yFyW+w6VlN9fYqmFtF7qsvCgNrrVuCBAkAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"architecture\" title=\"\" src=\"/static/5f9bc54493477318b0f91ac674514614/c5bb3/architecture.png\" srcset=\"/static/5f9bc54493477318b0f91ac674514614/04472/architecture.png 170w,\n/static/5f9bc54493477318b0f91ac674514614/9f933/architecture.png 340w,\n/static/5f9bc54493477318b0f91ac674514614/c5bb3/architecture.png 680w,\n/static/5f9bc54493477318b0f91ac674514614/bcb8c/architecture.png 879w\" sizes=\"(max-width: 680px) 100vw, 680px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n          </p>\n<h3 id=\"prerequisites\" style=\"position:relative;\"><a href=\"#prerequisites\" aria-label=\"prerequisites permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Prerequisites</h3>\n<p>For this demo, you need the following:</p>\n<ul>\n<li>Basic understanding of Linux operating systems and Kubernetes.</li>\n<li>An AWS account.</li>\n<li>Administrator or equivalent access to deploy the required resources.</li>\n<li><a href=\"https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html\" target=\"_blank\" rel=\"noopener noreferrer\">AWS Command Line Interface (AWS CLI)</a> installed and configured.</li>\n<li><a href=\"https://learn.hashicorp.com/tutorials/terraform/install-cli\" target=\"_blank\" rel=\"noopener noreferrer\">Terraform CLI</a> installed.</li>\n<li><a href=\"https://git-scm.com/book/en/v2/Getting-Started-Installing-Git\" target=\"_blank\" rel=\"noopener noreferrer\">Git CLI</a> installed.</li>\n<li><a href=\"https://kubernetes.io/docs/tasks/tools/install-kubectl/\" target=\"_blank\" rel=\"noopener noreferrer\">kubectl</a> and <a href=\"https://helm.sh/docs/intro/install/\" target=\"_blank\" rel=\"noopener noreferrer\">helm client</a> installed.</li>\n</ul>\n<h3 id=\"deploy-ekscluster\" style=\"position:relative;\"><a href=\"#deploy-ekscluster\" aria-label=\"deploy ekscluster permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Deploy EKS¬†Cluster</h3>\n<p>We prepared a Terraform template to deploy Amazon EKS cluster and ADOT Operator. Start by cloning the sample source code repository from GitHub.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> clone https://github.com/seifrajhi/topology-aware-routing-tf\n<span class=\"token builtin class-name\">cd</span> topology-aware-routing-tf/terraform</code></pre></div>\n<p>Run the following command to deploy the cluster.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">AWS_REGION</span><span class=\"token operator\">=</span><span class=\"token string\">\"eu-west-1\"</span>\nterraform init\nterraform plan\nterraform apply -auto-approve</code></pre></div>\n<p>Once the Terraform has completed, then you can set up kubectl by running this command:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">aws eks <span class=\"token parameter variable\">--region</span> <span class=\"token variable\">$AWS_REGION</span> update-kubeconfig <span class=\"token parameter variable\">--name</span> tar-demo-cluster</code></pre></div>\n<h3 id=\"deploy-the-demoapp\" style=\"position:relative;\"><a href=\"#deploy-the-demoapp\" aria-label=\"deploy the demoapp permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Deploy the Demo¬†App</h3>\n<p>Run the following command to deploy the sample application:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">cd</span> <span class=\"token punctuation\">..</span>/kubernetes\nkubectl apply --server-side <span class=\"token parameter variable\">-f</span> common.yaml\nkubectl apply --server-side <span class=\"token parameter variable\">-f</span> simple.yaml</code></pre></div>\n<p>Get the endpoint for UI component by running the following command:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">kubectl get svc ui-lb <span class=\"token parameter variable\">-n</span> ui <span class=\"token parameter variable\">-o</span> <span class=\"token assign-left variable\">jsonpath</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>.status.loadBalancer.ingress<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>.hostname<span class=\"token punctuation\">}</span></code></pre></div>\n<p>You can access the demo application by accessing this link. This displays an example online shopping site.</p>\n<h3 id=\"run-initial-loadtesting\" style=\"position:relative;\"><a href=\"#run-initial-loadtesting\" aria-label=\"run initial loadtesting permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Run Initial Load¬†Testing</h3>\n<p>Now we have deployed the EKS cluster and demo application, we can run a load test to simulate traffic and see how traffic between front-end and back-end is routed.</p>\n<p>We'll use <a href=\"https://github.com/rakyll/hey\" target=\"_blank\" rel=\"noopener noreferrer\">hey</a> to generate traffic, which is a small application that can send HTTP requests.</p>\n<p>Before you test TAR, you may want to know how traffic has been routed without TAR for comparison. You can determine this by performing a load test against this application, and traffic shows on AWS X-Ray service graph.</p>\n<p>Run load test against UI load balancer. Run the following command:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">UI_ENDPOINT</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>kubectl get svc ui-lb <span class=\"token parameter variable\">-n</span> ui <span class=\"token parameter variable\">-o</span> <span class=\"token assign-left variable\">jsonpath</span><span class=\"token operator\">=</span><span class=\"token string\">'{.status.loadBalancer.ingress[0].hostname}'</span><span class=\"token variable\">)</span></span>\nkubectl run load-generator <span class=\"token punctuation\">\\</span>\n  <span class=\"token parameter variable\">--image</span><span class=\"token operator\">=</span>williamyeh/hey:latest <span class=\"token punctuation\">\\</span>\n  <span class=\"token parameter variable\">--restart</span><span class=\"token operator\">=</span>Never -- <span class=\"token parameter variable\">-c</span> <span class=\"token number\">10</span> <span class=\"token parameter variable\">-q</span> <span class=\"token number\">5</span> <span class=\"token parameter variable\">-z</span> 60m http://<span class=\"token variable\">$UI_ENDPOINT</span>/home</code></pre></div>\n<h3 id=\"enable-tar-and-re-run-loadtesting\" style=\"position:relative;\"><a href=\"#enable-tar-and-re-run-loadtesting\" aria-label=\"enable tar and re run loadtesting permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Enable TAR and Re-run Load¬†Testing</h3>\n<p>Enabling TAR is easy: simply set the <code class=\"language-text\">service.kubernetes.io/topology-mode</code> annotation to <code class=\"language-text\">Auto</code> on a Service. The EndpointSlice controller will try to assign hints to each endpoint in an EndpointSlice to steer traffic to Pods within a given zone. It's important to understand the <a href=\"https://kubernetes.io/docs/concepts/services-networking/topology-aware-routing/#safeguards\" target=\"_blank\" rel=\"noopener noreferrer\">safeguards</a> and <a href=\"https://kubernetes.io/docs/concepts/services-networking/topology-aware-routing/#constraints\" target=\"_blank\" rel=\"noopener noreferrer\">constraints</a> implemented by the EndpointSlice controller and the kube-proxy, especially if routing isn't working as you expect.</p>\n<blockquote>\n<p><strong>Note:</strong> Prior to Kubernetes 1.27, this behavior was controlled using the <code class=\"language-text\">service.kubernetes.io/topology-aware-hints</code> annotation.</p>\n</blockquote>\n<p>Now let's enable TAR and re-run the load test to see if that improves traffic routing. Run the following command to enable TAR on the catalog Service:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">kubectl <span class=\"token parameter variable\">-n</span> catalog annotate svc catalog service.kubernetes.io/topology-mode<span class=\"token operator\">=</span>Auto</code></pre></div>\n<p>You can run the following command to check if hints are set:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">kubectl get endpointslices <span class=\"token parameter variable\">-l</span> kubernetes.io/service-name<span class=\"token operator\">=</span>catalog <span class=\"token parameter variable\">-n</span> catalog <span class=\"token parameter variable\">-o</span> yaml</code></pre></div>\n<p>You'll get results similar to the following example. If you see hints and a corresponding AZ name, then the TAR is enabled and was successfully activated.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">addressType</span><span class=\"token punctuation\">:</span> IPv4\n<span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> discovery.k8s.io/v1\n<span class=\"token key atrule\">endpoints</span><span class=\"token punctuation\">:</span>\n<span class=\"token punctuation\">-</span> <span class=\"token key atrule\">addresses</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> 10.0.10.100\n  <span class=\"token key atrule\">conditions</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">ready</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n    <span class=\"token key atrule\">serving</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n    <span class=\"token key atrule\">terminating</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span>\n  <span class=\"token key atrule\">hints</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">forZones</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> eu<span class=\"token punctuation\">-</span>west<span class=\"token punctuation\">-</span>1a</code></pre></div>\n<p>The control plane is very conservative about TAR decisions. If you run into issues, such as errors in the Service events or you find that hints are not populating on the EndpointSlice, then you should double-check that your topology labels have been applied and that Nodes are reporting values for allocatable CPU.</p>\n<p>Re-run the load test with the following command:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">UI_ENDPOINT</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>kubectl get svc ui-lb <span class=\"token parameter variable\">-n</span> ui <span class=\"token parameter variable\">-o</span> <span class=\"token assign-left variable\">jsonpath</span><span class=\"token operator\">=</span><span class=\"token string\">'{.status.loadBalancer.ingress[0].hostname}'</span><span class=\"token variable\">)</span></span>\nkubectl run load-generator <span class=\"token punctuation\">\\</span>\n  <span class=\"token parameter variable\">--image</span><span class=\"token operator\">=</span>williamyeh/hey:latest <span class=\"token punctuation\">\\</span>\n  <span class=\"token parameter variable\">--restart</span><span class=\"token operator\">=</span>Never -- <span class=\"token parameter variable\">-c</span> <span class=\"token number\">10</span> <span class=\"token parameter variable\">-q</span> <span class=\"token number\">5</span> <span class=\"token parameter variable\">-z</span> 60m http://<span class=\"token variable\">$UI_ENDPOINT</span>/home</code></pre></div>\n<p>Now you know that each UI pod only talks to one catalog pod. You can also find that UI pod always talks to catalog pod that resides on the same AZ. No inter-AZ data traffic cost is incurred in this scenario.</p>\n<h2 id=\"-endnotes\" style=\"position:relative;\"><a href=\"#-endnotes\" aria-label=\" endnotes permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>üîö End¬†Notes</h2>\n<p>Topology Aware Routing is a useful feature in Kubernetes that helps manage traffic flow by keeping it within the same zone where it originated. While it may not be suitable for every workload, it can be beneficial in environments with evenly distributed zonal traffic.</p>\n<p>In this blog post, we explored TAR and its effects on network traffic routing in Amazon EKS. We also provided a walkthrough on how to enable TAR for a Service and minimize the performance impact of overlay networking.</p>\n<br>\n<p><strong><em>Until next time, „Å§„Å•„Åè üéâ</em></strong></p>\n<blockquote>\n<p>üí° Thank you for Reading !! üôåüèªüòÅüìÉ, see you in the next talk.ü§ò  <strong><em>Until next time üéâ</em></strong></p>\n</blockquote>\n<p>üöÄ Thank you for sticking up till the end. If you have any questions/feedback regarding this talk feel free to connect with me:</p>\n<p><strong>‚ôªÔ∏è LinkedIn:</strong> <a href=\"https://www.linkedin.com/in/rajhi-saif/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.linkedin.com/in/rajhi-saif/</a></p>\n<p><strong>‚ôªÔ∏è X/Twitter:</strong> <a href=\"https://x.com/rajhisaifeddine\" target=\"_blank\" rel=\"noopener noreferrer\">https://x.com/rajhisaifeddine</a></p>\n<p><strong>The end ‚úåüèª</strong></p>\n<h1 align=\"center\">üî∞ Keep Learning !! Keep Sharing !! üî∞</h1>\n<p><strong>üìÖ Stay updated</strong></p>\n<p>Subscribe to our newsletter for more insights on AWS cloud computing and containers.</p>","timeToRead":6,"rawMarkdownBody":"\n> **How Topology Aware Routing Can Reduce Costs and Improve Network Performance üöÄ**\n\n## üîñ Introduction\n\n![alt text](image.png)\n\nAs Kubernetes clusters are increasingly deployed in multi-zone environments, it becomes important to keep network traffic within the zone where it originated. [Topology Aware Routing](https://kubernetes.io/docs/concepts/services-networking/topology-aware-routing/) (TAR) is a feature in Kubernetes that adjusts routing behavior to prefer keeping traffic in the zone it originated from.\n\nThis can help reduce costs or improve network performance by minimizing inter-zone traffic and ensuring that traffic reaches its destination with minimal delay.\n\nIn this blog post, we will learn about the concept of Kubernetes topology aware routing and discuss its benefits in terms of reducing latency and optimizing network traffic flow.\n\nWe will also show you how to enable Topology Aware Routing for a Service and minimize the performance impact of overlay networking. In this blog post, we will refer to Topology Aware Routing as TAR.\n\n<div class=\"note\">\n    <p><strong>üîµ Note:</strong></p>\n    <p>Prior to Kubernetes 1.27, this feature was known as Topology Aware Hints.</p>\n</div>\n<br>\n\n![topology-aware-routing-cover](./topology-aware-routing.jpg)\n\n## üåê Impact of TAR on Network Traffic in Amazon¬†EKS\n\nA best practice for architecting resilient systems in AWS is to leverage multiple Availability Zones (AZs). AWS Regions are composed of multiple AZs designed to be independent of each other and are separated by a meaningful physical distance to avoid correlated failure scenarios.\n\nAWS EKS makes it possible for customers to run their mission-critical workloads across multiple distinct AZs, providing increased availability by combining Amazon's global infrastructure with Kubernetes constructs such as pod topology spread constraints. However, when architecting workloads in this manner, there are considerations in terms of both latency and cost to consider. Pods within the same Amazon EKS cluster can easily communicate using a Kubernetes Cluster IP Service, which routes traffic to its associated pods even if they are in different AZs.\n\nAlthough this is a convenient way to take advantage of multiple AZs, some customers may want to bias traffic routing to pods in the same AZ as the originator. Keeping traffic in the same AZ benefits latency-sensitive workloads for low latency and can reduce inter-AZ data transfer costs.\n\nTAR is a feature that reached beta status in Kubernetes version 1.23 and became available in Amazon EKS version 1.24. It's intended to provide a mechanism that attempts to keep traffic closer to its origin within the same AZ or in another location.\n\n## üõ†Ô∏è Services in Kubernetes\n\nLet's begin by explaining how a Kubernetes Service operates before exploring TAR.\n\nWhen you create a Service, you define a selector to target specific pods. Kubernetes generates an Endpoints object, which maintains the IP addresses of the relevant pods. Subsequently, the Kubernetes controller assigns a Cluster IP to the Service‚Ää-‚Ääa virtual IP accessible only within the worker nodes of the Kubernetes cluster.\n\nThe kube-proxy DaemonSet instance, running on each node, establishes a set of [iptables rules](https://kubernetes.io/docs/reference/networking/virtual-ips/#proxy-modes) (or IP Virtual Server (IPVS) virtual servers, if enabled). When traffic is directed at the Cluster IP (or enters the cluster via NodePort), either iptables or IPVS routes the packet to a pod based on its load balancing algorithm.\n\nBy default, kube-proxy adds all pods from an Endpoints object to each node's iptables or IPVS, without considering factors like the availability zones (AZs) where the pods reside or the originating traffic zone.\n\nConsequently, packets are routed indiscriminately across AZs, potentially introducing latency and incurring inter-AZ data traffic costs.\n\n## üîÑ Understanding TAR Functionality\n\nTAR offers a different way to route traffic by sending some endpoints to kube-proxy. It relies on the EndpointSlices controller, which is more flexible than the Endpoints controller. Endpoints in the Endpoints controller only have pod IP addresses and ports, but EndpointSlices can include hints. Hints are extra labels on each endpoint.\n\nTAR adds a hint about which zone the endpoint is in. When a hint is added, kube-proxy filters the endpoints based on these hints. Usually, it picks endpoints in the same zone. When traffic reaches kube-proxy, it is directed only to pods in the same zone, avoiding traffic costs.\n\n### Hands-on example\n\nIn this walkthrough, you'll deploy an EKS cluster using Terraform. You can design your infrastructures as templates and use Terraform to provision, manage, and destroy them. Besides the cluster itself, Terraform also deploys the AWS Distro for [OpenTelemetry (ADOT) Operator](https://aws-otel.github.io/) via its [EKS Blueprints add-ons](https://github.com/aws-ia/terraform-aws-eks-blueprints-addons). The ADOT Operator enables a simplified experience for instrumenting your applications running on Amazon EKS to capture metrics and tracing data.\n\nWe'll use the ADOT Operator and AWS X-Ray to visualize the requests between workloads running on the Amazon EKS cluster. After the EKS cluster and its related infrastructure are created, we deploy the containers sample application, which shows traffic between separate front-end and back-end components. This allows us to explore how different configurations of the EKS worker nodes and pods affect TAR.\n\n![architecture](./architecture.png)\n\n### Prerequisites\n\nFor this demo, you need the following:\n\n- Basic understanding of Linux operating systems and Kubernetes.\n- An AWS account.\n- Administrator or equivalent access to deploy the required resources.\n- [AWS Command Line Interface (AWS CLI)](https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html) installed and configured.\n- [Terraform CLI](https://learn.hashicorp.com/tutorials/terraform/install-cli) installed.\n- [Git CLI](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git) installed.\n- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/) and [helm client](https://helm.sh/docs/intro/install/) installed.\n\n### Deploy EKS¬†Cluster\n\nWe prepared a Terraform template to deploy Amazon EKS cluster and ADOT Operator. Start by cloning the sample source code repository from GitHub.\n\n```bash\ngit clone https://github.com/seifrajhi/topology-aware-routing-tf\ncd topology-aware-routing-tf/terraform\n```\n\nRun the following command to deploy the cluster.\n\n```bash\nexport AWS_REGION=\"eu-west-1\"\nterraform init\nterraform plan\nterraform apply -auto-approve\n```\n\nOnce the Terraform has completed, then you can set up kubectl by running this command:\n\n```bash\naws eks --region $AWS_REGION update-kubeconfig --name tar-demo-cluster\n```\n\n### Deploy the Demo¬†App\n\nRun the following command to deploy the sample application:\n\n```bash\ncd ../kubernetes\nkubectl apply --server-side -f common.yaml\nkubectl apply --server-side -f simple.yaml\n```\n\nGet the endpoint for UI component by running the following command:\n\n```bash\nkubectl get svc ui-lb -n ui -o jsonpath={.status.loadBalancer.ingress[0].hostname}\n```\n\nYou can access the demo application by accessing this link. This displays an example online shopping site.\n\n### Run Initial Load¬†Testing\n\nNow we have deployed the EKS cluster and demo application, we can run a load test to simulate traffic and see how traffic between front-end and back-end is routed.\n\nWe'll use [hey](https://github.com/rakyll/hey) to generate traffic, which is a small application that can send HTTP requests.\n\nBefore you test TAR, you may want to know how traffic has been routed without TAR for comparison. You can determine this by performing a load test against this application, and traffic shows on AWS X-Ray service graph.\n\nRun load test against UI load balancer. Run the following command:\n\n```bash\nexport UI_ENDPOINT=$(kubectl get svc ui-lb -n ui -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')\nkubectl run load-generator \\\n  --image=williamyeh/hey:latest \\\n  --restart=Never -- -c 10 -q 5 -z 60m http://$UI_ENDPOINT/home\n```\n\n### Enable TAR and Re-run Load¬†Testing\n\nEnabling TAR is easy: simply set the `service.kubernetes.io/topology-mode` annotation to `Auto` on a Service. The EndpointSlice controller will try to assign hints to each endpoint in an EndpointSlice to steer traffic to Pods within a given zone. It's important to understand the [safeguards](https://kubernetes.io/docs/concepts/services-networking/topology-aware-routing/#safeguards) and [constraints](https://kubernetes.io/docs/concepts/services-networking/topology-aware-routing/#constraints) implemented by the EndpointSlice controller and the kube-proxy, especially if routing isn't working as you expect.\n\n> **Note:** Prior to Kubernetes 1.27, this behavior was controlled using the `service.kubernetes.io/topology-aware-hints` annotation.\n\nNow let's enable TAR and re-run the load test to see if that improves traffic routing. Run the following command to enable TAR on the catalog Service:\n\n```bash\nkubectl -n catalog annotate svc catalog service.kubernetes.io/topology-mode=Auto\n```\n\nYou can run the following command to check if hints are set:\n\n```bash\nkubectl get endpointslices -l kubernetes.io/service-name=catalog -n catalog -o yaml\n```\n\nYou'll get results similar to the following example. If you see hints and a corresponding AZ name, then the TAR is enabled and was successfully activated.\n\n```yaml\naddressType: IPv4\napiVersion: discovery.k8s.io/v1\nendpoints:\n- addresses:\n  - 10.0.10.100\n  conditions:\n    ready: true\n    serving: true\n    terminating: false\n  hints:\n    forZones:\n    - name: eu-west-1a\n```\n\nThe control plane is very conservative about TAR decisions. If you run into issues, such as errors in the Service events or you find that hints are not populating on the EndpointSlice, then you should double-check that your topology labels have been applied and that Nodes are reporting values for allocatable CPU.\n\nRe-run the load test with the following command:\n\n```bash\nexport UI_ENDPOINT=$(kubectl get svc ui-lb -n ui -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')\nkubectl run load-generator \\\n  --image=williamyeh/hey:latest \\\n  --restart=Never -- -c 10 -q 5 -z 60m http://$UI_ENDPOINT/home\n```\n\nNow you know that each UI pod only talks to one catalog pod. You can also find that UI pod always talks to catalog pod that resides on the same AZ. No inter-AZ data traffic cost is incurred in this scenario.\n\n## üîö End¬†Notes\n\nTopology Aware Routing is a useful feature in Kubernetes that helps manage traffic flow by keeping it within the same zone where it originated. While it may not be suitable for every workload, it can be beneficial in environments with evenly distributed zonal traffic.\n\nIn this blog post, we explored TAR and its effects on network traffic routing in Amazon EKS. We also provided a walkthrough on how to enable TAR for a Service and minimize the performance impact of overlay networking.\n\n<br>\n\n**_Until next time, „Å§„Å•„Åè üéâ_**\n\n> üí° Thank you for Reading !! üôåüèªüòÅüìÉ, see you in the next talk.ü§ò  **_Until next time üéâ_**\n\nüöÄ Thank you for sticking up till the end. If you have any questions/feedback regarding this talk feel free to connect with me:\n\n**‚ôªÔ∏è LinkedIn:** https://www.linkedin.com/in/rajhi-saif/\n\n**‚ôªÔ∏è X/Twitter:** https://x.com/rajhisaifeddine\n\n**The end ‚úåüèª**\n\n<h1 align=\"center\">üî∞ Keep Learning !! Keep Sharing !! üî∞</h1>\n\n**üìÖ Stay updated**\n\nSubscribe to our newsletter for more insights on AWS cloud computing and containers.\n","wordCount":{"words":1408},"frontmatter":{"id":"5ab0a90a233c4a66544bf46b","path":"/blog/topology-aware-routing-kubernetes/","humanDate":"Nov 1, 2024","fullDate":"2024-11-01","title":"Improve Network Performance with Topology Aware Routing in Amazon EKS ‚úí","keywords":["Kubernetes","AWS EKS","Network Performance","AWS","DevOps"],"excerpt":"Discover how topology aware routing in Kubernetes can reduce costs and improve network performance.","cover":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABr0lEQVR42o2S227TQBRF+8H8CuITeIRf4KG8I4RQUSu7IfGl8TX22PF17Ngzi7EbIQIpqqytsUfb65wzs2+0UmitL3Qye4PSDLNaNc6a0Xy307NXnaWv6OYCaB6MDnLG7RRihlxBatZo1PjtvPoWj34NsBuM2aximPF6zdefT9x+37DZhwRVRyLVCju2it4UXd6V+guo1GKCth/5cJvRdiPSmNwBLHfDvfUFe3uHk2a4cnEqPn0bud/K60B9BkopyXJB17Z4YYwVJLhBwFMSs4szdkmO7e9p294UN+dpjmSer428HLCBFqKgKATTNFEdS0ohyA8Zwuzn2QGRZZRFwTBI8vxAHIUGOF0HLhDbtrEsi7JJyGqHvMhwXI+d46xK0hRRhxStj+d5PD5uOJ1O63Tqj3v4PXLTNFRVZeKgOFalGb2mqWvTmaCujvRdS1UWSNNhWZZEUXQBeiE2pto8s49itmHKxnf54T5gOT7bIMb29si+/6erF4HPN66J+gnX/BfIkTfv3vP242fCCdxmWmOl9StzqM6hTU3G/F4Rj3D3JHhIjibYpkA//xe2AH8BO5FQ9eUzMXAAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/9e0ee14cda75263528143430f4303c82/14790/image.png","srcSet":"/static/9e0ee14cda75263528143430f4303c82/793cf/image.png 750w,\n/static/9e0ee14cda75263528143430f4303c82/a12a4/image.png 1080w,\n/static/9e0ee14cda75263528143430f4303c82/587aa/image.png 1366w,\n/static/9e0ee14cda75263528143430f4303c82/14790/image.png 1920w","sizes":"100vw"},"sources":[{"srcSet":"/static/9e0ee14cda75263528143430f4303c82/bb245/image.webp 750w,\n/static/9e0ee14cda75263528143430f4303c82/25880/image.webp 1080w,\n/static/9e0ee14cda75263528143430f4303c82/a2ab7/image.webp 1366w,\n/static/9e0ee14cda75263528143430f4303c82/37e4d/image.webp 1920w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5489583333333333}}},"coverCredits":"Photo by Saifeddine Rajhi"}}},"pageContext":{"prevThought":{"frontmatter":{"path":"/blog/k8s-dynamic-resource-allocation-dra/","title":"Dynamic Resource Allocation in Kubernetes","date":"2024-11-02 14:00:00"},"excerpt":"Dynamic Resource Allocation (DRA) in Kubernetes üìö Introduction Dynamic Resource Allocation (DRA) is a new API for requesting resources in‚Ä¶"},"nextThought":{"frontmatter":{"path":"/blog/in-memory-databases-comparison/","title":"A Battle of Lightning-Fast In-Memory Databases in the Real World ‚ö°","date":"2024-11-01 18:30:00"},"excerpt":"Redis, KeyDB, Dragonfly, Skytable as examples‚ö° ‚ÑπÔ∏è Introduction In today's world, businesses need fast ways to store and access their data‚Ä¶"}}},"staticQueryHashes":["1271460761","1321585977"],"slicesMap":{}}