{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/in-place-kubernetes-pod-resizing/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p><strong>In-Place Pod Resizing in Action ‚öôÔ∏è</strong></p>\n</blockquote>\n<h2 id=\"-kick-off\" style=\"position:relative;\"><a href=\"#-kick-off\" aria-label=\" kick off permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>üéå Kick-off</h2>\n<p>Welcome to this exciting deep dive into one of the newest features in Kubernetes management‚Ää‚Äî‚Ääthe <strong>In-Place Pod Resource Resizing</strong> feature!</p>\n<p>In-place pod resource resizing is a new feature in Kubernetes that allows you to resize the CPU and memory resources allocated to a pod without restarting it. This can be a major advantage for many applications, as it can help to improve performance and efficiency without causing any downtime.</p>\n<p>In this blog post, we will take a deep dive into the in-place pod resource resizing feature. We will discuss how it works, the benefits it offers, and how to use it. We will also show you how to resize a pod in-place in action.</p>\n<p><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC1UlEQVR42pVUS08TURSef+AvcOHahS6MiSHElcSNLlwY3bmRlODCGNFgoyGBxBCFREh04wIKAkWtYMBGYsOjWmsxPESgGB5CSwdoCy3M9DGP+3ln7sz0QZvGm5zk5px7v/Pdc757OJRZKlGhqGqBj1CTNT8h5a6BO+ahhzUwc0mqglhG0E3KS6DQM8RKTsoDmqFAfBO3fvShytOBc2Pt1Nr0/e2AEzP7YQOUJgcpw1AP0nUk4qG3DydHW/BkwY2v0TVsiQfYpDa5twb7r1GcGmlG7bRTZy9T1jvpwxKAqpFrYhLunk6EkDUYkzz2bC/IWdz87sANnwNTNGHNxCsrzpns9NXTA8zMMBdNIClqAaBWK62MWj2Hwgu4SEtw4t0DNMwOWXXlYBZ6aQmoqwMOD6HohJk/FFXQ9OYAzf0JhGKS7vsr7OOq9zXOfn4GzlGLMT6YB2iy29gA5uetelJyeDGcxGnbNq4/3cOVpl2cqd9GB/UR485u+khvnqhki2ooy0BXFxCNwhTGn7CEC/ciaP+QxFuvgIFJAW2uBM7fjSAYlvSKqaRQGTnARAKw2XRAxQiMBEQKyKNvQsD4fBpfZlNwTgmous/D9U1kGlUI0+MxHabTgNtNT0j0AAu0uZK41rKLYb8A988UPk2nMEqTaE9//j7JaqaW+ikmuscDRCIGfQJ+X0F1Aw9bZwxDPhEf/SLuvIyjmjLcjskF4igENLvc2gr09jJ5yOzh/uUMLj/eQY2d2aVHO/AtZQwJlfvLZpqVFWBw0BK5atxYDknw/s5gaiGD5S3J0Gil4WCyXFwEurtzoJQpKXoX0YpccdqYB1IpoLERcDhyoIQ9T0tp9YA2D6paYXyZoJqE1tcZqPYVYzEGwPP0Ewt0DAUAux2Ix1GqM1zxLLQyB4OsUePjTFL19UB/P7C6CszN/d+APfYcUWSMFAWVFlc2ooFqVtyAUgnzAP8BH+HVxHuVEvkAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"resize\" title=\"\" src=\"/static/ae6469f85d6a2da77b247cfb4f4a4f7c/0b533/resize.png\" srcset=\"/static/ae6469f85d6a2da77b247cfb4f4a4f7c/04472/resize.png 170w,\n/static/ae6469f85d6a2da77b247cfb4f4a4f7c/9f933/resize.png 340w,\n/static/ae6469f85d6a2da77b247cfb4f4a4f7c/0b533/resize.png 500w\" sizes=\"(max-width: 500px) 100vw, 500px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n          </p>\n<h3 id=\"-exploring-the-long-awaited-in-place-pod-resource-resizing-in-kubernetes-127\" style=\"position:relative;\"><a href=\"#-exploring-the-long-awaited-in-place-pod-resource-resizing-in-kubernetes-127\" aria-label=\" exploring the long awaited in place pod resource resizing in kubernetes 127 permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>üìò Exploring the Long-Awaited In-Place Pod Resource Resizing in Kubernetes 1.27</h3>\n<p>Like many, I have been waiting for the ability to resize Kubernetes pods without restarting them for several years. This feature is now available in <a href=\"https://kubernetes.io/docs/setup/release/notes/\" target=\"_blank\" rel=\"noopener noreferrer\">Kubernetes 1.27</a>, and I am excited to try it out.</p>\n<p>This feature, called in-place pod resource resizing, allows you to change the CPU and memory resources allocated to a pod without having to restart it. This is a major advantage for many applications, as it can help to improve performance and efficiency without causing any downtime.</p>\n<p>The way in-place pod resource resizing works is by making the pod spec resources mutable. This means that Kubernetes can update the underlying c-group allocation in-place. This is particularly useful in the case of scaling pods vertically, such as with Kubernetes' built-in <a href=\"https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler\" target=\"_blank\" rel=\"noopener noreferrer\">Vertical Pod Autoscaler (VPA)</a>.</p>\n<p>Vertical scaling proves indispensable in various use cases, especially with stateful database workloads experiencing bursty traffic, where service disruptions can be costly. Additionally, <a href=\"https://www.youtube.com/watch?v=jjfa1cVJLwc&#x26;t=818s\" target=\"_blank\" rel=\"noopener noreferrer\">an exciting talk at KubeCon North America 2022</a> showcased the utilization of this in-place feature with eBPF, adding to its versatility.</p>\n<p>In this blog post, I will show you how to try out in-place pod resource resizing. I will also discuss the new changes you'll see in the pod spec. There are many ways to do this; this is just one simple example.</p>\n<h3 id=\"-a-hands-on-guide-to-in-place-pod-resource-resizing-in-kubernetes\" style=\"position:relative;\"><a href=\"#-a-hands-on-guide-to-in-place-pod-resource-resizing-in-kubernetes\" aria-label=\" a hands on guide to in place pod resource resizing in kubernetes permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>üèó A Hands-On Guide to In-Place Pod Resource Resizing in Kubernetes</h3>\n<p>The new feature is introduced under the name <strong>InPlacePodVerticalScaling</strong>.</p>\n<p>Let's now start a test pod. Let's say that your application can safely change the amount of CPUs without restarting, but changing the amount of memory requires a restart. For example, a pod running a database has no problem with a CPU count change while running, but decreasing the amount of memory would cause unexpected behavior.</p>\n<p>To reflect this in the pod YAML, you need to set the <code class=\"language-text\">restartPolicy</code> to <code class=\"language-text\">RestartContainer</code> for the memory resource. Otherwise, the default behavior will be to attempt to update the resource in-place.</p>\n<p>Here is an example of a pod YAML that you can use:</p>\n<p><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 68.82352941176471%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABOElEQVR42q2TbW+CMBzEwaFmQecG4uRBKeBAQFDCTPb9v1dzu3YvtuwVBF/8k6Zpf9xdDyMoCmmJHIZ3hvH+gHHjWjqiwTpuMQ8v04FR1sq0vGMlbnrDnArcHGvpJS0WhxartIctumnArWikR8uvxwvmQQVzX04D0qL00wZOesPmdMc6+4SlstwVHB7wit/1ECAPy+R0RZx3cMsvbPMeFpUqtTZVOxmjiBuYfjUQSIXKbpg08Dj2odbARVhhtj/jyS8x4xhDo1DAFSGCKotzBz9tsSs6iKbHC7PdqI8cR9SJ2WiFrA/s6KJro5RZQcleVlhGNe2X44BLXgio7JmX9SaB+hH+zmAgLStVEYGuoMr4pz6jIP9fec7QxccNbwSae2V5QhcJkGqxZTXU4zjZVVdFd28kTP0U3xi3Y/Xa9Be9AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"pod\" title=\"\" src=\"/static/a36b0cd2c702a14531a42b8b9bd867dc/c5bb3/pod.png\" srcset=\"/static/a36b0cd2c702a14531a42b8b9bd867dc/04472/pod.png 170w,\n/static/a36b0cd2c702a14531a42b8b9bd867dc/9f933/pod.png 340w,\n/static/a36b0cd2c702a14531a42b8b9bd867dc/c5bb3/pod.png 680w,\n/static/a36b0cd2c702a14531a42b8b9bd867dc/b12f7/pod.png 1020w,\n/static/a36b0cd2c702a14531a42b8b9bd867dc/b5a09/pod.png 1360w,\n/static/a36b0cd2c702a14531a42b8b9bd867dc/29007/pod.png 1600w\" sizes=\"(max-width: 680px) 100vw, 680px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n          </p>\n<p>To apply the YAML and ensure it's running, follow these steps:</p>\n<ol>\n<li><strong>Save the YAML content to a file</strong>, for example, <code class=\"language-text\">test-pod.yaml</code>.</li>\n<li><strong>Apply the YAML</strong> to create the pod in your Kubernetes cluster.</li>\n<li><strong>Wait until the pod is ready and running</strong>:</li>\n</ol>\n<p><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 26.47058823529412%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAvElEQVR42pWQXROBYBCFX6WPV3GFSqWakmQkkQbh//+nzLHlxpWPizO7szv77NllZrhqlCgBM1L0zFUn0Uo7MSP5Sz2TohpUjR7V0BY1eHCE4h8xTu8YeDnYdPk3lMlu3qj+AdwvoZL6dgZ5XoBN4hdwGr/lPywYxteHFl3AZxn06IxBeIJAZ7dwwVoTfE/OK4hOBsnd0dAXKA/KRwuRyJVib6B5BfpOjmF8g0I17m4JlkOm3igoPv/QSPAE3LiAkFSLvEAAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"apply\" title=\"\" src=\"/static/ad7d776e6114215c74b4b2b8c0165d6a/c5bb3/apply.png\" srcset=\"/static/ad7d776e6114215c74b4b2b8c0165d6a/04472/apply.png 170w,\n/static/ad7d776e6114215c74b4b2b8c0165d6a/9f933/apply.png 340w,\n/static/ad7d776e6114215c74b4b2b8c0165d6a/c5bb3/apply.png 680w,\n/static/ad7d776e6114215c74b4b2b8c0165d6a/b12f7/apply.png 1020w,\n/static/ad7d776e6114215c74b4b2b8c0165d6a/b5a09/apply.png 1360w,\n/static/ad7d776e6114215c74b4b2b8c0165d6a/29007/apply.png 1600w\" sizes=\"(max-width: 680px) 100vw, 680px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n          </p>\n<p>Under the pod spec, one of the new and notable features to observe is the <code class=\"language-text\">resizePolicy</code>. This section defines how the pod's resources can be resized and specifies the behavior for different resource types, such as memory and CPU.</p>\n<p>For memory resources, the <code class=\"language-text\">resizePolicy</code> indicates that changes to the memory allocation require a restart of the container. This is denoted by setting the <code class=\"language-text\">restartPolicy</code> to <code class=\"language-text\">RestartContainer</code> for the \"memory\" resource. In contrast, for CPU resources, a restart is not necessary during resizing, as indicated by the <code class=\"language-text\">restartPolicy</code> set to <code class=\"language-text\">NotRequired</code> for the \"cpu\" resource.</p>\n<p><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 32.94117647058823%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAoUlEQVR42q3Ryw6CMBQE0EYBDWJQEJSHgFBagSKoIf7/l42lG9eNLCazO5mbS8yqBgnuIOeFss86WHGDddQsA3qZgCtjRK1cyv8HnbTDKRcIC4HdtQO5NFjNeMh/0QG3SYukfKCgg2qnfOPIPrDSHmYiVLTATdyiYgM4f4KyEYd6UqCdj3BuL9VaoCGf4cuTg6KHJ9vOB7h0Uti8kgRMC/wCE2OyHfFWZT0AAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"pod-resize\" title=\"\" src=\"/static/8ad89fa2a863c446eae064582084b46f/c5bb3/pod-resize.png\" srcset=\"/static/8ad89fa2a863c446eae064582084b46f/04472/pod-resize.png 170w,\n/static/8ad89fa2a863c446eae064582084b46f/9f933/pod-resize.png 340w,\n/static/8ad89fa2a863c446eae064582084b46f/c5bb3/pod-resize.png 680w,\n/static/8ad89fa2a863c446eae064582084b46f/b12f7/pod-resize.png 1020w,\n/static/8ad89fa2a863c446eae064582084b46f/b5a09/pod-resize.png 1360w,\n/static/8ad89fa2a863c446eae064582084b46f/29007/pod-resize.png 1600w\" sizes=\"(max-width: 680px) 100vw, 680px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n          </p>\n<p>Under the status field, new and noteworthy information includes the <code class=\"language-text\">allocatedResources</code> and <code class=\"language-text\">resources</code> fields. <code class=\"language-text\">allocatedResources</code> reflects the current resource allocation to the pod's containers, while <code class=\"language-text\">resources</code> represents the desired or to-be-updated resource specifications.</p>\n<p>This distinction provides real-time insights into resource utilization and allows effective monitoring and optimization of the pod's resource management. These fields are nested under <code class=\"language-text\">containerStatuses</code>, presenting a comprehensive view of each container's status and resource usage. Understanding this information is vital for fine-tuning resource allocation in the Kubernetes environment.</p>\n<p><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 45.88235294117647%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAw0lEQVR42qWSXQuCMBSGt8I+0CIqp6u0TNOZzgzq//+uYPJ2VjfdphcvG5zx8LycMZmq1yzLDfOV4YEyzEYU3/PP8LA0bCJLEyQNxEljf26wPdVw5BX0oF+YUGYV1zjnd0R5Cz+5wT1UQ4BF58gSq7jCNNLw0gcNimHARVQjpNqeNRMFeF/Yr6F/1HCp+igcAPsAA9XZS5Q22F1azI8taFvDDEcEkInGhrY8JltbuzeQh2QoFFWusaavs8yeH8s+UNvsDahL4yLhlNB6AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"cpu-mem\" title=\"\" src=\"/static/6080ec0104832e08d9f74b51e2eee444/c5bb3/cpu-mem.png\" srcset=\"/static/6080ec0104832e08d9f74b51e2eee444/04472/cpu-mem.png 170w,\n/static/6080ec0104832e08d9f74b51e2eee444/9f933/cpu-mem.png 340w,\n/static/6080ec0104832e08d9f74b51e2eee444/c5bb3/cpu-mem.png 680w,\n/static/6080ec0104832e08d9f74b51e2eee444/b12f7/cpu-mem.png 1020w,\n/static/6080ec0104832e08d9f74b51e2eee444/b5a09/cpu-mem.png 1360w,\n/static/6080ec0104832e08d9f74b51e2eee444/29007/cpu-mem.png 1600w\" sizes=\"(max-width: 680px) 100vw, 680px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n          </p>\n<h3 id=\"cpu-resize\" style=\"position:relative;\"><a href=\"#cpu-resize\" aria-label=\"cpu resize permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>CPU Resize</h3>\n<p>To begin, let's adjust the CPU limits of the pod, increasing them from 2 to 3. We'll accomplish this using the command line by applying a patch:</p>\n<p><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 19.411764705882355%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAjUlEQVR42oWPWQrDMAxEcwYvqS3bavGSn97/eGaqqCGUptCPx4wGe4SWZ1vnyg7OCE6whwrWWmH3/sz+sfRe5xgdrVWo9opaK7ZtgO+M3huYCwpH5CIwSZ4Ewi2s10JKcfIjIaUon96PKYVzzoUQKWiZ5jmoZllAkl8K5aRpjNXzdv3llW9/zJ9l3nu8AJakZeSoTodTAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"check\" title=\"\" src=\"/static/b28b0ae003f90c89860865a77272f8e6/c5bb3/check.png\" srcset=\"/static/b28b0ae003f90c89860865a77272f8e6/04472/check.png 170w,\n/static/b28b0ae003f90c89860865a77272f8e6/9f933/check.png 340w,\n/static/b28b0ae003f90c89860865a77272f8e6/c5bb3/check.png 680w,\n/static/b28b0ae003f90c89860865a77272f8e6/b12f7/check.png 1020w,\n/static/b28b0ae003f90c89860865a77272f8e6/b5a09/check.png 1360w,\n/static/b28b0ae003f90c89860865a77272f8e6/29007/check.png 1600w\" sizes=\"(max-width: 680px) 100vw, 680px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n          </p>\n<p>Upon inspecting the pod now (using <code class=\"language-text\">kubectl get pod testinplace -o yaml</code>), it is probable (though not guaranteed) that you will observe the appearance of the <code class=\"language-text\">resize</code> field. Additionally, you will notice the pod spec resources displaying the updated value, while the pod status resources retain the previous value.</p>\n<p><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 84.70588235294117%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAABCElEQVR42q2UUY6EIBBEPcJKN8g4joCgsOvu/S9HUtO4Nxj8MDF8vFRZT4YzmPrYCKQYmhnc+QxhpfqcNb5GBtENQK25uhcjBYXXsx86KEX1YQnnIcDFQBH1AZmptlQ/+4iyGzjvobXuAXI1hnHmEXvUF4w6Ug4klUdZuFXOSSPnAucclFKfAWdL9RrjOiAYY/oqLzPX4FpVRqve6+IgkLp5RvQKu6iTQkvZkVAWrm5lHJvCcoeHDTgZwm9W8Oskh/oeD0tS4qG+Fu4apSU0MshfGXGIh8b0pbzEbi/fkjBHQim5z8MG9Ov/5XBEhn9Nok5HQmt13RzJxTAjbAkxJlhrP/r92rd/A8Agp/m+ZJiyAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"resized\" title=\"\" src=\"/static/ae92bf0867b1c10086bd3265e9a817db/c5bb3/resized.png\" srcset=\"/static/ae92bf0867b1c10086bd3265e9a817db/04472/resized.png 170w,\n/static/ae92bf0867b1c10086bd3265e9a817db/9f933/resized.png 340w,\n/static/ae92bf0867b1c10086bd3265e9a817db/c5bb3/resized.png 680w,\n/static/ae92bf0867b1c10086bd3265e9a817db/b12f7/resized.png 1020w,\n/static/ae92bf0867b1c10086bd3265e9a817db/b5a09/resized.png 1360w,\n/static/ae92bf0867b1c10086bd3265e9a817db/29007/resized.png 1600w\" sizes=\"(max-width: 680px) 100vw, 680px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n          </p>\n<p>The duration for the pod to transition from <code class=\"language-text\">resize: InProgress</code> to <code class=\"language-text\">resize: complete</code> may vary depending on various factors. The time taken for the resizing process to finish could be different for different pods or environments.</p>\n<p>In case you encounter a different flag, such as <code class=\"language-text\">resize: Infeasible</code>, it indicates that the resizing process is not feasible. To address this, check your node's available resources to ensure they are sufficient to accommodate the requested changes. Insufficient resources may prevent the successful completion of the resizing operation.</p>\n<h3 id=\"memory-resize\" style=\"position:relative;\"><a href=\"#memory-resize\" aria-label=\"memory resize permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Memory Resize</h3>\n<p>Continuing with memory adjustments, let's raise the limits from 1G to 2G:</p>\n<p><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 16.470588235294116%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAjklEQVR42lWOXQ7DIAyDe4eSP9pRoHR92P1vV8kLdNK2B8uxQck3vapd665gVqgaRLorzMw7HrOwgJg8E4jchcfbPIehEL6atpKv8zzQWsXT/Th27K2MOZeE5nnLCSkveKSIXFdsxeU5Ln7c5H8hUbjE+sXgdOQf+EMyw6I4zU2mevcWnbgTuvqy3v8ufAOtiE133IxCWgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"mem-resize\" title=\"\" src=\"/static/20cf12e2b44f781630e3999632ef162b/c5bb3/mem-resize.png\" srcset=\"/static/20cf12e2b44f781630e3999632ef162b/04472/mem-resize.png 170w,\n/static/20cf12e2b44f781630e3999632ef162b/9f933/mem-resize.png 340w,\n/static/20cf12e2b44f781630e3999632ef162b/c5bb3/mem-resize.png 680w,\n/static/20cf12e2b44f781630e3999632ef162b/b12f7/mem-resize.png 1020w,\n/static/20cf12e2b44f781630e3999632ef162b/b5a09/mem-resize.png 1360w,\n/static/20cf12e2b44f781630e3999632ef162b/29007/mem-resize.png 1600w\" sizes=\"(max-width: 680px) 100vw, 680px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n          </p>\n<p>The process remains identical to the previous step, involving the use of the <code class=\"language-text\">resize</code> tag and inspecting the pod status. To ensure that the resizing process is complete, verify the corresponding field or resource status. In my setup, this typically takes approximately 15 seconds to 1 minute, although it's essential to note that there's currently a bug that might cause it to take longer.</p>\n<p>After confirming the successful resizing completion, proceed to verify whether the restart occurred based on the flag we set earlier. The restart behavior should align with the specified flag, where memory changes triggered a container restart, while CPU changes did not necessitate a restart. This validation ensures that the In-Place Pod Resource Resizing feature is functioning as expected, allowing for seamless resource updates without unnecessary container disruptions.</p>\n<p><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 16.470588235294116%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAgklEQVR42nWO0QrDIAxF+yHVaqyJWmsnK+z//0u40zK2l/XhkksI52Sq0TaXLRZDMETQWkMrBdUz+phqnn/9s7/LxKU22R+g1UNKBe8HFmvgRLrEgCRgjek6HkJD7hLeA3NpUg4QBzjvwVsCeUY6Xx0awCkiP88O3eBjgE/p+/E/4BtAi1PY8kHTmgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"checking\" title=\"\" src=\"/static/1cb62436359cdcff026dd877b0073ee3/c5bb3/checking.png\" srcset=\"/static/1cb62436359cdcff026dd877b0073ee3/04472/checking.png 170w,\n/static/1cb62436359cdcff026dd877b0073ee3/9f933/checking.png 340w,\n/static/1cb62436359cdcff026dd877b0073ee3/c5bb3/checking.png 680w,\n/static/1cb62436359cdcff026dd877b0073ee3/b12f7/checking.png 1020w,\n/static/1cb62436359cdcff026dd877b0073ee3/b5a09/checking.png 1360w,\n/static/1cb62436359cdcff026dd877b0073ee3/29007/checking.png 1600w\" sizes=\"(max-width: 680px) 100vw, 680px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n          </p>\n<p>Indeed, the process is complete! It's exciting to have experienced the new In-Place Pod Resource Resizing feature firsthand. The ability to resize resources without disrupting the pod is a game-changer, especially for stateful applications that require vertical pod autoscaling.</p>\n<h2 id=\"-takeaway\" style=\"position:relative;\"><a href=\"#-takeaway\" aria-label=\" takeaway permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>üîö Takeaway</h2>\n<p>In this blog post, we have explored the new in-place pod resource resizing feature in Kubernetes. We have seen how this feature can be used to resize pods without having to restart them.</p>\n<p>In-place pod resource resizing is a powerful feature that can be used to improve the performance and efficiency of Kubernetes applications. It can also be used to reduce downtime and improve the overall reliability of Kubernetes clusters.</p>\n<p>I hope this blog post has been helpful.</p>\n<br>\n<p><strong><em>Until next time, „Å§„Å•„Åè üéâ</em></strong></p>\n<blockquote>\n<p>üí° Thank you for Reading !! üôåüèªüòÅüìÉ, see you in the next blog.ü§ò  <strong><em>Until next time üéâ</em></strong></p>\n</blockquote>\n<p>üöÄ Thank you for sticking up till the end. If you have any questions/feedback regarding this blog feel free to connect with me:</p>\n<p><strong>‚ôªÔ∏è LinkedIn:</strong> <a href=\"https://www.linkedin.com/in/rajhi-saif/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.linkedin.com/in/rajhi-saif/</a></p>\n<p><strong>‚ôªÔ∏è X/Twitter:</strong> <a href=\"https://x.com/rajhisaifeddine\" target=\"_blank\" rel=\"noopener noreferrer\">https://x.com/rajhisaifeddine</a></p>\n<p><strong>The end ‚úåüèª</strong></p>\n<h1 align=\"center\">üî∞ Keep Learning !! Keep Sharing !! üî∞</h1>\n<p><strong>üìÖ Stay updated</strong></p>\n<p>Subscribe to our newsletter for more insights on AWS cloud computing and containers.</p>","timeToRead":5,"rawMarkdownBody":"\n> **In-Place Pod Resizing in Action ‚öôÔ∏è**\n\n## üéå Kick-off\n\nWelcome to this exciting deep dive into one of the newest features in Kubernetes management‚Ää‚Äî‚Ääthe **In-Place Pod Resource Resizing** feature!\n\nIn-place pod resource resizing is a new feature in Kubernetes that allows you to resize the CPU and memory resources allocated to a pod without restarting it. This can be a major advantage for many applications, as it can help to improve performance and efficiency without causing any downtime.\n\nIn this blog post, we will take a deep dive into the in-place pod resource resizing feature. We will discuss how it works, the benefits it offers, and how to use it. We will also show you how to resize a pod in-place in action.\n\n![resize](./resize.png)\n\n### üìò Exploring the Long-Awaited In-Place Pod Resource Resizing in Kubernetes 1.27\n\nLike many, I have been waiting for the ability to resize Kubernetes pods without restarting them for several years. This feature is now available in [Kubernetes 1.27](https://kubernetes.io/docs/setup/release/notes/), and I am excited to try it out.\n\nThis feature, called in-place pod resource resizing, allows you to change the CPU and memory resources allocated to a pod without having to restart it. This is a major advantage for many applications, as it can help to improve performance and efficiency without causing any downtime.\n\nThe way in-place pod resource resizing works is by making the pod spec resources mutable. This means that Kubernetes can update the underlying c-group allocation in-place. This is particularly useful in the case of scaling pods vertically, such as with Kubernetes' built-in [Vertical Pod Autoscaler (VPA)](https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler).\n\nVertical scaling proves indispensable in various use cases, especially with stateful database workloads experiencing bursty traffic, where service disruptions can be costly. Additionally, [an exciting talk at KubeCon North America 2022](https://www.youtube.com/watch?v=jjfa1cVJLwc&t=818s) showcased the utilization of this in-place feature with eBPF, adding to its versatility.\n\nIn this blog post, I will show you how to try out in-place pod resource resizing. I will also discuss the new changes you'll see in the pod spec. There are many ways to do this; this is just one simple example.\n\n### üèó A Hands-On Guide to In-Place Pod Resource Resizing in Kubernetes\n\nThe new feature is introduced under the name **InPlacePodVerticalScaling**.\n\nLet's now start a test pod. Let's say that your application can safely change the amount of CPUs without restarting, but changing the amount of memory requires a restart. For example, a pod running a database has no problem with a CPU count change while running, but decreasing the amount of memory would cause unexpected behavior.\n\nTo reflect this in the pod YAML, you need to set the `restartPolicy` to `RestartContainer` for the memory resource. Otherwise, the default behavior will be to attempt to update the resource in-place.\n\nHere is an example of a pod YAML that you can use:\n\n![pod](./pod.png)\n\nTo apply the YAML and ensure it's running, follow these steps:\n\n1. **Save the YAML content to a file**, for example, `test-pod.yaml`.\n2. **Apply the YAML** to create the pod in your Kubernetes cluster.\n3. **Wait until the pod is ready and running**:\n\n![apply](./apply.png)\n\nUnder the pod spec, one of the new and notable features to observe is the `resizePolicy`. This section defines how the pod's resources can be resized and specifies the behavior for different resource types, such as memory and CPU.\n\nFor memory resources, the `resizePolicy` indicates that changes to the memory allocation require a restart of the container. This is denoted by setting the `restartPolicy` to `RestartContainer` for the \"memory\" resource. In contrast, for CPU resources, a restart is not necessary during resizing, as indicated by the `restartPolicy` set to `NotRequired` for the \"cpu\" resource.\n\n![pod-resize](./pod-resize.png)\n\nUnder the status field, new and noteworthy information includes the `allocatedResources` and `resources` fields. `allocatedResources` reflects the current resource allocation to the pod's containers, while `resources` represents the desired or to-be-updated resource specifications.\n\nThis distinction provides real-time insights into resource utilization and allows effective monitoring and optimization of the pod's resource management. These fields are nested under `containerStatuses`, presenting a comprehensive view of each container's status and resource usage. Understanding this information is vital for fine-tuning resource allocation in the Kubernetes environment.\n\n![cpu-mem](./cpu-mem.png)\n\n### CPU Resize\n\nTo begin, let's adjust the CPU limits of the pod, increasing them from 2 to 3. We'll accomplish this using the command line by applying a patch:\n\n![check](./check.png)\n\nUpon inspecting the pod now (using `kubectl get pod testinplace -o yaml`), it is probable (though not guaranteed) that you will observe the appearance of the `resize` field. Additionally, you will notice the pod spec resources displaying the updated value, while the pod status resources retain the previous value.\n\n![resized](./resized.png)\n\nThe duration for the pod to transition from `resize: InProgress` to `resize: complete` may vary depending on various factors. The time taken for the resizing process to finish could be different for different pods or environments.\n\nIn case you encounter a different flag, such as `resize: Infeasible`, it indicates that the resizing process is not feasible. To address this, check your node's available resources to ensure they are sufficient to accommodate the requested changes. Insufficient resources may prevent the successful completion of the resizing operation.\n\n### Memory Resize\n\nContinuing with memory adjustments, let's raise the limits from 1G to 2G:\n\n![mem-resize](./mem-resize.png)\n\nThe process remains identical to the previous step, involving the use of the `resize` tag and inspecting the pod status. To ensure that the resizing process is complete, verify the corresponding field or resource status. In my setup, this typically takes approximately 15 seconds to 1 minute, although it's essential to note that there's currently a bug that might cause it to take longer.\n\nAfter confirming the successful resizing completion, proceed to verify whether the restart occurred based on the flag we set earlier. The restart behavior should align with the specified flag, where memory changes triggered a container restart, while CPU changes did not necessitate a restart. This validation ensures that the In-Place Pod Resource Resizing feature is functioning as expected, allowing for seamless resource updates without unnecessary container disruptions.\n\n![checking](./checking.png)\n\nIndeed, the process is complete! It's exciting to have experienced the new In-Place Pod Resource Resizing feature firsthand. The ability to resize resources without disrupting the pod is a game-changer, especially for stateful applications that require vertical pod autoscaling.\n\n## üîö Takeaway\n\nIn this blog post, we have explored the new in-place pod resource resizing feature in Kubernetes. We have seen how this feature can be used to resize pods without having to restart them.\n\nIn-place pod resource resizing is a powerful feature that can be used to improve the performance and efficiency of Kubernetes applications. It can also be used to reduce downtime and improve the overall reliability of Kubernetes clusters.\n\nI hope this blog post has been helpful.\n\n<br>\n\n**_Until next time, „Å§„Å•„Åè üéâ_**\n\n> üí° Thank you for Reading !! üôåüèªüòÅüìÉ, see you in the next blog.ü§ò  **_Until next time üéâ_**\n\nüöÄ Thank you for sticking up till the end. If you have any questions/feedback regarding this blog feel free to connect with me:\n\n**‚ôªÔ∏è LinkedIn:** https://www.linkedin.com/in/rajhi-saif/\n\n**‚ôªÔ∏è X/Twitter:** https://x.com/rajhisaifeddine\n\n**The end ‚úåüèª**\n\n<h1 align=\"center\">üî∞ Keep Learning !! Keep Sharing !! üî∞</h1>\n\n**üìÖ Stay updated**\n\nSubscribe to our newsletter for more insights on AWS cloud computing and containers.\n","wordCount":{"words":1156},"frontmatter":{"id":"53ee158b46c1beb798048aa1","path":"/blog/in-place-kubernetes-pod-resizing/","humanDate":"Oct 28, 2024","fullDate":"2024-10-28","title":"In-Place Kubernetes Pod Resource Resizing Feature: A Deep Dive üîç","keywords":["Kubernetes","pod resizing","SRE","k8s","DevOps","AWS"],"excerpt":"Explore the in-place resizing feature for Kubernetes pods, allowing dynamic resource adjustments without downtime, enhancing application performance and resource management.","cover":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAAClElEQVR42h3R20uTARjH8fdG0ZZWpju8vnPu0PZO57Z3c25ueXZ21Eo8kUonMyjNzJB1QDS1VtEgS8QkIhA7EEUlhVSQSlF0ELoIDKKLCKKgi/6Bb29dPFcPD8/zfH7C2RPNhDatx+S141JrtKeZnXUhzBYD0ZoSWppr8YR85DslnLJE7HA9719MIftcrDHqyS/zcyneRe+RVsKBfIRvn2YZOtlGSaUbq1XLmd4mLvQ1ITvNOB0ivogbm82EryCHDRUBPryYJD7agUGRiTZUsbm2lB11YeSgl6HYHoQfnxf4+HyCgQNVVLiziLgtdDSWY82zUFBgwx324lWHFVnH8PAxFufvobeIeIJ5NNSVUxxS0OqzCASdPJg5h/B16QFPbsY53d/E3no/dtmE0aSjrNSjvmlFo1mBwy6hOEWuJo5yY2KA9BwD9a1b0Ila0jMyyHXk0tBYSSIxjPD22TUeT4/Q1bkV0SKxvsKPy2fFE8hTDQtRFBtFhQ6yrRKnDjYwFe8mOTmJ8SvHmZ48RWWpQvvOGnbt3kF/rBth7lacmYkYvfs2Ul6mEAzJmH0WilXstu2FbAvbccg5iEYt2zdGWJ6/zuhgF3++v+bLwhTtnZtpaa+muMTPxcsjCImRTmq3FFEUsFMZLcZb6KJ6g4+iCjcGi57ygIykGum0GWjS07g11sfvN+P8XLrN0zujOCIKGm0mRtc6FuYfIsR6WtSrHOTYROR8q2qYq/r5CEf9yC4TAbcZSdJhzJVITUlBFDOJqstez55n8f4ISjRC8qo0DvXu58+vZYT6thqsamL6PDMpq9NJXalBn234n7Jk1pJlyEQrZpGt+q7911+RgpCUzMu5MWZvDmIOFuDyOHj1aJJ3C3f5CxvCVvoORko5AAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/07c324a8fbb2073dd11932a738d0da1b/6bffe/resizing-cover.png","srcSet":"/static/07c324a8fbb2073dd11932a738d0da1b/402d0/resizing-cover.png 750w,\n/static/07c324a8fbb2073dd11932a738d0da1b/6bffe/resizing-cover.png 825w","sizes":"100vw"},"sources":[{"srcSet":"/static/07c324a8fbb2073dd11932a738d0da1b/5e135/resizing-cover.webp 750w,\n/static/07c324a8fbb2073dd11932a738d0da1b/63ce3/resizing-cover.webp 825w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.44969696969696976}}},"coverCredits":"Photo by Saifeddine Rajhi"}}},"pageContext":{"prevThought":{"frontmatter":{"path":"/blog/kubernetes-pod-priority-preemption/","title":"Kubernetes Pod Priority and Preemption: How to Ensure Your Critical Pods Get the Resources They Need üöÄ","date":"2024-10-28 20:30:00"},"excerpt":"A Guide to Managing Pod Priorities üìä üóØ Introduction When running a Kubernetes cluster, it's important to ensure that your critical pods‚Ä¶"},"nextThought":{"frontmatter":{"path":"/blog/chaos-engineering-kubernetes/","title":"Chaos Engineering on Kubernetes: A Beginner's Guide: Revel In Chaos","date":"2024-10-28 17:06:00"},"excerpt":"Easy Guide to Chaos Testing on Kubernetes üó∫ Overview üëÄ Making sure our systems work well is super important in today's fast world. This‚Ä¶"}}},"staticQueryHashes":["1271460761","1321585977"],"slicesMap":{}}