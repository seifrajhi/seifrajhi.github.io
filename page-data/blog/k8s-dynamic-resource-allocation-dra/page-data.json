{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/k8s-dynamic-resource-allocation-dra/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p><strong>Dynamic Resource Allocation (DRA) in Kubernetes</strong></p>\n</blockquote>\n<h2 id=\"-introduction\" style=\"position:relative;\"><a href=\"#-introduction\" aria-label=\" introduction permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>📚 Introduction</h2>\n<p>Dynamic Resource Allocation (DRA) is a new API for requesting resources in Kubernetes, introduced to enable networking technologies. This blog post explores the concept of DRA, its importance, and how it enhances resource management in Kubernetes.</p>\n<h2 id=\"what-is-dynamic-resource-allocation-dra\" style=\"position:relative;\"><a href=\"#what-is-dynamic-resource-allocation-dra\" aria-label=\"what is dynamic resource allocation dra permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>What is Dynamic Resource Allocation (DRA)?</h2>\n<p>Dynamic Resource Allocation (DRA) is a new API for requesting resources in Kubernetes, allowing for more flexible and efficient allocation of resources such as GPUs or network devices to workloads.</p>\n<h2 id=\"why-is-there-a-need-for-device-plugins-in-kubernetes\" style=\"position:relative;\"><a href=\"#why-is-there-a-need-for-device-plugins-in-kubernetes\" aria-label=\"why is there a need for device plugins in kubernetes permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Why is there a need for Device Plugins in Kubernetes?</h2>\n<p>Device Plugins are needed in Kubernetes because Kubernetes does not natively support specialized hardware like GPUs or network interfaces. Device Plugins help to utilize these resources within Kubernetes workloads.</p>\n<h2 id=\"limitations-of-the-device-plugin-framework\" style=\"position:relative;\"><a href=\"#limitations-of-the-device-plugin-framework\" aria-label=\"limitations of the device plugin framework permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Limitations of the Device Plugin Framework</h2>\n<p>The Device Plugin framework has limitations such as not supporting shared resources, difficulty in handling unlimited resources, and a lack of support for advanced configurations for different instances of the same resource.</p>\n<h2 id=\"how-dra-solves-device-plugin-framework-issues\" style=\"position:relative;\"><a href=\"#how-dra-solves-device-plugin-framework-issues\" aria-label=\"how dra solves device plugin framework issues permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>How DRA Solves Device Plugin Framework Issues</h2>\n<p>DRA solves the issues with the Device Plugin framework by providing a more flexible and vendor-controlled approach to resource allocation, allowing for shared resources, no requirement for pre-defining resource limits, and advanced configurations for each resource instance.</p>\n<h2 id=\"-storage-options-in-kubernetes\" style=\"position:relative;\"><a href=\"#-storage-options-in-kubernetes\" aria-label=\" storage options in kubernetes permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>💾 Storage Options in Kubernetes</h2>\n<p>Storage options in Kubernetes include scratch space for temporary data and persistent storage solutions like NFS mounts and CSI (Container Storage Interface).</p>\n<h2 id=\"-device-plugins-and-their-constraints\" style=\"position:relative;\"><a href=\"#-device-plugins-and-their-constraints\" aria-label=\" device plugins and their constraints permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>🔌 Device Plugins and Their Constraints</h2>\n<p>Device plugins are necessary for utilizing specialized hardware within Kubernetes, but they have constraints that DRA aims to overcome.</p>\n<h2 id=\"-key-concepts-in-dra\" style=\"position:relative;\"><a href=\"#-key-concepts-in-dra\" aria-label=\" key concepts in dra permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>🔄 Key Concepts in DRA</h2>\n<p>The Array API introduces concepts like <strong>DeviceClass</strong>, <strong>ResourceClaim</strong>, <strong>ResourceClaimTemplates</strong>, and <strong>ResourceSlice</strong>, providing more control and flexibility.</p>\n<h3 id=\"deviceclass\" style=\"position:relative;\"><a href=\"#deviceclass\" aria-label=\"deviceclass permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>DeviceClass</h3>\n<p>A <code class=\"language-text\">DeviceClass</code> defines the characteristics of a device. It specifies the driver and parameters for a device, providing a structured way to request resources. Here is an example of a <code class=\"language-text\">DeviceClass</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> resource.k8s.io/v1alpha3\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> DeviceClass\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> device.com\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">selectors</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">cel</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">expression</span><span class=\"token punctuation\">:</span> device.driver == \"device.com\"</code></pre></div>\n<h3 id=\"resourceclaim\" style=\"position:relative;\"><a href=\"#resourceclaim\" aria-label=\"resourceclaim permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>ResourceClaim</h3>\n<p>A <code class=\"language-text\">ResourceClaim</code> is analogous to a Persistent Volume Claim (PVC) but for device resources. It is a request for a specific type of resource and is used to allocate resources to a pod. Here is an example of a <code class=\"language-text\">ResourceClaim</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> resource.k8s.io/v1alpha3\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> ResourceClaim\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> claim1\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">devices</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">requests</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> gpu\n      <span class=\"token key atrule\">deviceClassName</span><span class=\"token punctuation\">:</span> device.com</code></pre></div>\n<h3 id=\"resourceclaimtemplate\" style=\"position:relative;\"><a href=\"#resourceclaimtemplate\" aria-label=\"resourceclaimtemplate permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>ResourceClaimTemplate</h3>\n<p>A <code class=\"language-text\">ResourceClaimTemplate</code> is used to generate <code class=\"language-text\">ResourceClaim</code> objects. When a pod references a <code class=\"language-text\">ResourceClaimTemplate</code>, a new <code class=\"language-text\">ResourceClaim</code> is generated for each entry in the pod spec's <code class=\"language-text\">resourceClaims</code> section. Here is an example of a <code class=\"language-text\">ResourceClaimTemplate</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> resource.k8s.io/v1alpha3\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> ResourceClaimTemplate\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> claim1\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">devices</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">requests</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> gpu\n        <span class=\"token key atrule\">deviceClassName</span><span class=\"token punctuation\">:</span> device.com</code></pre></div>\n<h3 id=\"resourceslice\" style=\"position:relative;\"><a href=\"#resourceslice\" aria-label=\"resourceslice permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>ResourceSlice</h3>\n<p>A <code class=\"language-text\">ResourceSlice</code> represents a slice of resources available on a node. It is used to manage and allocate resources to <code class=\"language-text\">ResourceClaims</code>. Here is an example of a <code class=\"language-text\">ResourceSlice</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> resource.k8s.io/v1alpha3\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> ResourceSlice\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> slice1\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">devices</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">basic</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">attributes</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">family</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">string</span><span class=\"token punctuation\">:</span> Arc\n        <span class=\"token key atrule\">model</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">string</span><span class=\"token punctuation\">:</span> A770\n      <span class=\"token key atrule\">capacity</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">memory</span><span class=\"token punctuation\">:</span> 16288Mi\n        <span class=\"token key atrule\">millicores</span><span class=\"token punctuation\">:</span> 1k\n    <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> 0000<span class=\"token punctuation\">-</span>03<span class=\"token punctuation\">-</span>00<span class=\"token punctuation\">-</span>0<span class=\"token punctuation\">-</span><span class=\"token number\">0x56a0</span>\n  <span class=\"token key atrule\">driver</span><span class=\"token punctuation\">:</span> device.com\n  <span class=\"token key atrule\">nodeName</span><span class=\"token punctuation\">:</span> node1\n  <span class=\"token key atrule\">pool</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">generation</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span>\n    <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> pool1\n    <span class=\"token key atrule\">resourceSliceCount</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span></code></pre></div>\n<p>Here is an example of a pod specification that uses Dynamic Resource Allocation (DRA):</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> Pod\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> test<span class=\"token punctuation\">-</span>claim\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">restartPolicy</span><span class=\"token punctuation\">:</span> Never\n  <span class=\"token key atrule\">containers</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> with<span class=\"token punctuation\">-</span>resource\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> xxxxx\n  <span class=\"token key atrule\">resourceClaims</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> resource\n    <span class=\"token key atrule\">resourceClaimName</span><span class=\"token punctuation\">:</span> zzzz</code></pre></div>\n<p>In this example:</p>\n<ul>\n<li>The pod is named <code class=\"language-text\">test-claim</code>.</li>\n<li>It has a single container named <code class=\"language-text\">with-resource</code> that uses the specified image.</li>\n<li>The pod references a <code class=\"language-text\">ResourceClaim</code> named <code class=\"language-text\">zzzz</code> through the <code class=\"language-text\">resourceClaims</code> field, ensuring that the required resources are allocated and available for the pod.</li>\n</ul>\n<h2 id=\"-allocation-process-in-dra\" style=\"position:relative;\"><a href=\"#-allocation-process-in-dra\" aria-label=\" allocation process in dra permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>📝 Allocation Process in DRA</h2>\n<p>The allocation process in DRA can occur immediately or be delayed until a pod referencing the resource claim is created, influencing pod scheduling.</p>\n<h2 id=\"️-implementing-a-dra-driver\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-implementing-a-dra-driver\" aria-label=\"️ implementing a dra driver permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>🛠️ Implementing a DRA Driver</h2>\n<p>Implementing a DRA driver involves defining a name, CRDs, coordination mechanisms, and providing implementations for the controller and node plugin.</p>\n<h2 id=\"resource-drivers\" style=\"position:relative;\"><a href=\"#resource-drivers\" aria-label=\"resource drivers permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Resource Drivers</h2>\n<p>In the context of Dynamic Resource Allocation (DRA) in Kubernetes, a <strong>resource driver</strong> is a component that manages the allocation and deallocation of specific types of resources, such as GPUs, network devices, or other specialized hardware. The resource driver is responsible for:</p>\n<ol>\n<li><strong>Discovery</strong>: Identifying and reporting the available resources on each node in the Kubernetes cluster.</li>\n<li><strong>Allocation</strong>: Handling requests for resources from pods and allocating the appropriate resources to meet those requests.</li>\n<li><strong>Preparation</strong>: Preparing the allocated resources for use by the pods, which may involve configuring the hardware or setting up necessary software components.</li>\n<li><strong>Unpreparation</strong>: Cleaning up and releasing the resources when they are no longer needed by the pods.</li>\n</ol>\n<p>The resource driver typically consists of two main components:</p>\n<ol>\n<li><strong>Controller</strong>: A centralized component that coordinates with the Kubernetes scheduler to decide which nodes can service incoming resource claims. It handles the creation and management of <code class=\"language-text\">ResourceClaim</code> and <code class=\"language-text\">ResourceSlice</code> objects.</li>\n<li><strong>Node Plugin</strong>: A daemon running on each node that interacts with the hardware to perform discovery, allocation, preparation, and unpreparation of resources. It reports the available resources to the controller and ensures that the resources are correctly configured for use by the pods.</li>\n</ol>\n<p>The resource driver uses Custom Resource Definitions (CRDs) such as <code class=\"language-text\">ResourceClass</code>, <code class=\"language-text\">ResourceClaim</code>, <code class=\"language-text\">ResourceClaimTemplate</code>, and <code class=\"language-text\">ResourceSlice</code> to define and manage the resources within the Kubernetes cluster. These CRDs provide a standardized way to request, allocate, and manage resources, enabling more flexible and efficient resource management.</p>\n<h2 id=\"-container-device-interface-cdi\" style=\"position:relative;\"><a href=\"#-container-device-interface-cdi\" aria-label=\" container device interface cdi permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>🔗 Container Device Interface (CDI)</h2>\n<p><strong>CDI (Container Device Interface)</strong> is a specification for exposing devices to containers, which is utilized by container runtimes like containerd and CRI-O. It introduces an abstract notion of a device as a resource. Such devices are uniquely specified by a fully-qualified name that is constructed from a vendor ID, a device class, and a name that is unique per vendor ID-device class pair.</p>\n<h2 id=\"requirements\" style=\"position:relative;\"><a href=\"#requirements\" aria-label=\"requirements permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Requirements</h2>\n<ul>\n<li>Kubernetes 1.31+, with <code class=\"language-text\">DynamicResourceAllocation</code> feature-flag enabled, and other cluster parameters</li>\n<li>Container runtime needs to support CDI:\n<ul>\n<li>CRI-O v1.23.0 or newer</li>\n<li>Containerd v1.7 or newer</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"enable-cdi-in-containerd\" style=\"position:relative;\"><a href=\"#enable-cdi-in-containerd\" aria-label=\"enable cdi in containerd permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Enable CDI in Containerd</h3>\n<p>Containerd has CDI enabled by default since version 2.0. For older versions (1.7 and above) CDI has to be enabled in Containerd config by enabling <code class=\"language-text\">enable_cdi</code> and <code class=\"language-text\">cdi_specs_dir</code>. Example <code class=\"language-text\">/etc/containerd/config.toml</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"toml\"><pre class=\"language-toml\"><code class=\"language-toml\"><span class=\"token key property\">version</span> <span class=\"token punctuation\">=</span> <span class=\"token number\">2</span>\n<span class=\"token punctuation\">[</span><span class=\"token table class-name\">plugins</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">[</span><span class=\"token table class-name\">plugins.\"io.containerd.grpc.v1.cri\"</span><span class=\"token punctuation\">]</span>\n    <span class=\"token key property\">enable_cdi</span> <span class=\"token punctuation\">=</span> <span class=\"token boolean\">true</span>\n    <span class=\"token key property\">cdi_specs_dir</span> <span class=\"token punctuation\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"/etc/cdi\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"/var/run/cdi\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<h2 id=\"limitations\" style=\"position:relative;\"><a href=\"#limitations\" aria-label=\"limitations permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Limitations</h2>\n<ul>\n<li>Currently max 640 GPUs can be requested for one resource claim (10 PCIe devices, each with 64 SR-IOV VFs = 640 VFs on the same node).</li>\n<li>v0.6.0 only supports K8s v1.31 which does not have partitionable devices support, therefore this release does not support dynamic GPU SR-IOV configuration.</li>\n<li>v0.6.0 does not support classic DRA and only relies on Structured Parameters DRA.</li>\n<li>v0.6.0 drops Alertmanager web-hook used for (experimental) GPU health management support.</li>\n</ul>\n<h2 id=\"enabling-dynamic-resource-allocation\" style=\"position:relative;\"><a href=\"#enabling-dynamic-resource-allocation\" aria-label=\"enabling dynamic resource allocation permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Enabling Dynamic Resource Allocation</h2>\n<p>Dynamic resource allocation is an alpha feature and only enabled when the <code class=\"language-text\">DynamicResourceAllocation</code> feature gate and the <code class=\"language-text\">resource.k8s.io/v1alpha3</code> API group are enabled. For details on that, see the <code class=\"language-text\">--feature-gates</code> and <code class=\"language-text\">--runtime-config</code> kube-apiserver parameters. kube-scheduler, kube-controller-manager, and kubelet also need the feature gate.</p>\n<p>When a resource driver uses a control plane controller, then the <code class=\"language-text\">DRAControlPlaneController</code> feature gate has to be enabled in addition to <code class=\"language-text\">DynamicResourceAllocation</code>.</p>\n<p>A quick check whether a Kubernetes cluster supports the feature is to list <code class=\"language-text\">DeviceClass</code> objects with:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">kubectl get deviceclasses</code></pre></div>\n<p>If your cluster supports dynamic resource allocation, the response is either a list of <code class=\"language-text\">DeviceClass</code> objects or:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">No resources found</code></pre></div>\n<p>If not supported, this error is printed instead:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">error: the server doesn't have a resource <span class=\"token builtin class-name\">type</span> <span class=\"token string\">\"deviceclasses\"</span></code></pre></div>\n<p>A control plane controller is supported when it is possible to create a <code class=\"language-text\">ResourceClaim</code> where the <code class=\"language-text\">spec.controller</code> field is set. When the <code class=\"language-text\">DRAControlPlaneController</code> feature is disabled, that field automatically gets cleared when storing the <code class=\"language-text\">ResourceClaim</code>.</p>\n<p>The default configuration of kube-scheduler enables the \"DynamicResources\" plugin if and only if the feature gate is enabled and when using the v1 configuration API. Custom configurations may have to be modified to include it.</p>\n<p>In addition to enabling the feature in the cluster, a resource driver also has to be installed. Please refer to the driver's documentation for details.</p>\n<h3 id=\"scheduling-details\" style=\"position:relative;\"><a href=\"#scheduling-details\" aria-label=\"scheduling details permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Scheduling Details</h3>\n<p>When using a control plane controller, the resource driver handles the allocation of resources in cooperation with the Kubernetes scheduler. The scheduler checks all <code class=\"language-text\">ResourceClaims</code> needed by a pod and creates a <code class=\"language-text\">PodSchedulingContext</code> object, informing the resource drivers about nodes that are considered suitable for the pod. The resource drivers respond by excluding nodes that don't have enough resources left. Once the scheduler has this information, it selects a node and stores the choice in the <code class=\"language-text\">PodSchedulingContext</code> object. The resource drivers then allocate the resources, and the pod gets scheduled. Without a control plane controller, the scheduler uses structured parameters to allocate resources directly from <code class=\"language-text\">ResourceSlice</code> objects, tracking which resources have been allocated and selecting from the remaining resources.</p>\n<h3 id=\"monitoring-resources\" style=\"position:relative;\"><a href=\"#monitoring-resources\" aria-label=\"monitoring resources permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Monitoring Resources</h3>\n<p>The kubelet provides a gRPC service to enable the discovery of dynamic resources for running pods. This service allows resource drivers to report the availability and status of resources on each node. The gRPC endpoints provide detailed information about the resources allocated to each pod, helping administrators monitor and manage resource usage effectively. This monitoring capability is crucial for ensuring that resources are being used efficiently and for troubleshooting any issues that may arise with resource allocation.</p>\n<h3 id=\"pre-scheduled-pods\" style=\"position:relative;\"><a href=\"#pre-scheduled-pods\" aria-label=\"pre scheduled pods permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Pre-scheduled Pods</h3>\n<p>When a pod is created with the <code class=\"language-text\">spec.nodeName</code> field already set, the scheduler is bypassed. If the required <code class=\"language-text\">ResourceClaims</code> for the pod do not exist, are not allocated, or are not reserved, the kubelet will fail to run the pod and periodically re-check until the requirements are fulfilled. This situation can occur due to version skew, configuration issues, or feature gate settings. The kube-controller-manager detects such scenarios and attempts to make the pod runnable by triggering the allocation and reservation of the required <code class=\"language-text\">ResourceClaims</code>. However, it is generally better to avoid bypassing the scheduler to prevent resource blocking and ensure efficient resource allocation.</p>\n<h2 id=\"-references\" style=\"position:relative;\"><a href=\"#-references\" aria-label=\" references permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>🔗 References</h2>\n<ul>\n<li><a href=\"https://kubernetes.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Kubernetes</a></li>\n<li><a href=\"https://kubernetes-csi.github.io/docs/\" target=\"_blank\" rel=\"noopener noreferrer\">Container Storage Interface (CSI)</a></li>\n<li><a href=\"https://github.com/container-orchestrated-devices/container-device-interface\" target=\"_blank\" rel=\"noopener noreferrer\">Container Device Interface (CDI)</a></li>\n</ul>","timeToRead":7,"rawMarkdownBody":"> **Dynamic Resource Allocation (DRA) in Kubernetes**\n\n## 📚 Introduction\n\nDynamic Resource Allocation (DRA) is a new API for requesting resources in Kubernetes, introduced to enable networking technologies. This blog post explores the concept of DRA, its importance, and how it enhances resource management in Kubernetes.\n\n\n## What is Dynamic Resource Allocation (DRA)?\n\nDynamic Resource Allocation (DRA) is a new API for requesting resources in Kubernetes, allowing for more flexible and efficient allocation of resources such as GPUs or network devices to workloads.\n\n## Why is there a need for Device Plugins in Kubernetes?\n\nDevice Plugins are needed in Kubernetes because Kubernetes does not natively support specialized hardware like GPUs or network interfaces. Device Plugins help to utilize these resources within Kubernetes workloads.\n\n## Limitations of the Device Plugin Framework\n\nThe Device Plugin framework has limitations such as not supporting shared resources, difficulty in handling unlimited resources, and a lack of support for advanced configurations for different instances of the same resource.\n\n## How DRA Solves Device Plugin Framework Issues\n\nDRA solves the issues with the Device Plugin framework by providing a more flexible and vendor-controlled approach to resource allocation, allowing for shared resources, no requirement for pre-defining resource limits, and advanced configurations for each resource instance.\n\n## 💾 Storage Options in Kubernetes\n\nStorage options in Kubernetes include scratch space for temporary data and persistent storage solutions like NFS mounts and CSI (Container Storage Interface).\n\n## 🔌 Device Plugins and Their Constraints\n\nDevice plugins are necessary for utilizing specialized hardware within Kubernetes, but they have constraints that DRA aims to overcome.\n\n## 🔄 Key Concepts in DRA\n\nThe Array API introduces concepts like **DeviceClass**, **ResourceClaim**, **ResourceClaimTemplates**, and **ResourceSlice**, providing more control and flexibility.\n\n### DeviceClass\n\nA `DeviceClass` defines the characteristics of a device. It specifies the driver and parameters for a device, providing a structured way to request resources. Here is an example of a `DeviceClass`:\n\n```yaml\napiVersion: resource.k8s.io/v1alpha3\nkind: DeviceClass\nmetadata:\n  name: device.com\nspec:\n  selectors:\n  - cel:\n      expression: device.driver == \"device.com\"\n```\n\n### ResourceClaim\n\nA `ResourceClaim` is analogous to a Persistent Volume Claim (PVC) but for device resources. It is a request for a specific type of resource and is used to allocate resources to a pod. Here is an example of a `ResourceClaim`:\n\n```yaml\napiVersion: resource.k8s.io/v1alpha3\nkind: ResourceClaim\nmetadata:\n  name: claim1\nspec:\n  devices:\n    requests:\n    - name: gpu\n      deviceClassName: device.com\n```\n\n### ResourceClaimTemplate\n\nA `ResourceClaimTemplate` is used to generate `ResourceClaim` objects. When a pod references a `ResourceClaimTemplate`, a new `ResourceClaim` is generated for each entry in the pod spec's `resourceClaims` section. Here is an example of a `ResourceClaimTemplate`:\n\n```yaml\napiVersion: resource.k8s.io/v1alpha3\nkind: ResourceClaimTemplate\nmetadata:\n  name: claim1\nspec:\n  spec:\n    devices:\n      requests:\n      - name: gpu\n        deviceClassName: device.com\n```\n\n### ResourceSlice\n\nA `ResourceSlice` represents a slice of resources available on a node. It is used to manage and allocate resources to `ResourceClaims`. Here is an example of a `ResourceSlice`:\n\n```yaml\napiVersion: resource.k8s.io/v1alpha3\nkind: ResourceSlice\nmetadata:\n  name: slice1\nspec:\n  devices:\n  - basic:\n      attributes:\n        family:\n          string: Arc\n        model:\n          string: A770\n      capacity:\n        memory: 16288Mi\n        millicores: 1k\n    name: 0000-03-00-0-0x56a0\n  driver: device.com\n  nodeName: node1\n  pool:\n    generation: 0\n    name: pool1\n    resourceSliceCount: 1\n```\n\nHere is an example of a pod specification that uses Dynamic Resource Allocation (DRA):\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: test-claim\nspec:\n  restartPolicy: Never\n  containers:\n  - name: with-resource\n    image: xxxxx\n  resourceClaims:\n  - name: resource\n    resourceClaimName: zzzz\n```\n\nIn this example:\n\n- The pod is named `test-claim`.\n- It has a single container named `with-resource` that uses the specified image.\n- The pod references a `ResourceClaim` named `zzzz` through the `resourceClaims` field, ensuring that the required resources are allocated and available for the pod.\n\n## 📝 Allocation Process in DRA\n\nThe allocation process in DRA can occur immediately or be delayed until a pod referencing the resource claim is created, influencing pod scheduling.\n\n## 🛠️ Implementing a DRA Driver\n\nImplementing a DRA driver involves defining a name, CRDs, coordination mechanisms, and providing implementations for the controller and node plugin.\n\n## Resource Drivers\n\nIn the context of Dynamic Resource Allocation (DRA) in Kubernetes, a **resource driver** is a component that manages the allocation and deallocation of specific types of resources, such as GPUs, network devices, or other specialized hardware. The resource driver is responsible for:\n\n1. **Discovery**: Identifying and reporting the available resources on each node in the Kubernetes cluster.\n2. **Allocation**: Handling requests for resources from pods and allocating the appropriate resources to meet those requests.\n3. **Preparation**: Preparing the allocated resources for use by the pods, which may involve configuring the hardware or setting up necessary software components.\n4. **Unpreparation**: Cleaning up and releasing the resources when they are no longer needed by the pods.\n\nThe resource driver typically consists of two main components:\n\n1. **Controller**: A centralized component that coordinates with the Kubernetes scheduler to decide which nodes can service incoming resource claims. It handles the creation and management of `ResourceClaim` and `ResourceSlice` objects.\n2. **Node Plugin**: A daemon running on each node that interacts with the hardware to perform discovery, allocation, preparation, and unpreparation of resources. It reports the available resources to the controller and ensures that the resources are correctly configured for use by the pods.\n\nThe resource driver uses Custom Resource Definitions (CRDs) such as `ResourceClass`, `ResourceClaim`, `ResourceClaimTemplate`, and `ResourceSlice` to define and manage the resources within the Kubernetes cluster. These CRDs provide a standardized way to request, allocate, and manage resources, enabling more flexible and efficient resource management.\n\n## 🔗 Container Device Interface (CDI)\n\n**CDI (Container Device Interface)** is a specification for exposing devices to containers, which is utilized by container runtimes like containerd and CRI-O. It introduces an abstract notion of a device as a resource. Such devices are uniquely specified by a fully-qualified name that is constructed from a vendor ID, a device class, and a name that is unique per vendor ID-device class pair.\n\n## Requirements\n\n- Kubernetes 1.31+, with `DynamicResourceAllocation` feature-flag enabled, and other cluster parameters\n- Container runtime needs to support CDI:\n  - CRI-O v1.23.0 or newer\n  - Containerd v1.7 or newer\n\n### Enable CDI in Containerd\n\nContainerd has CDI enabled by default since version 2.0. For older versions (1.7 and above) CDI has to be enabled in Containerd config by enabling `enable_cdi` and `cdi_specs_dir`. Example `/etc/containerd/config.toml`:\n\n```toml\nversion = 2\n[plugins]\n  [plugins.\"io.containerd.grpc.v1.cri\"]\n    enable_cdi = true\n    cdi_specs_dir = [\"/etc/cdi\", \"/var/run/cdi\"]\n```\n\n## Limitations\n\n- Currently max 640 GPUs can be requested for one resource claim (10 PCIe devices, each with 64 SR-IOV VFs = 640 VFs on the same node).\n- v0.6.0 only supports K8s v1.31 which does not have partitionable devices support, therefore this release does not support dynamic GPU SR-IOV configuration.\n- v0.6.0 does not support classic DRA and only relies on Structured Parameters DRA.\n- v0.6.0 drops Alertmanager web-hook used for (experimental) GPU health management support.\n\n## Enabling Dynamic Resource Allocation\n\nDynamic resource allocation is an alpha feature and only enabled when the `DynamicResourceAllocation` feature gate and the `resource.k8s.io/v1alpha3` API group are enabled. For details on that, see the `--feature-gates` and `--runtime-config` kube-apiserver parameters. kube-scheduler, kube-controller-manager, and kubelet also need the feature gate.\n\nWhen a resource driver uses a control plane controller, then the `DRAControlPlaneController` feature gate has to be enabled in addition to `DynamicResourceAllocation`.\n\nA quick check whether a Kubernetes cluster supports the feature is to list `DeviceClass` objects with:\n\n```bash\nkubectl get deviceclasses\n```\n\nIf your cluster supports dynamic resource allocation, the response is either a list of `DeviceClass` objects or:\n\n```shell\nNo resources found\n```\n\nIf not supported, this error is printed instead:\n\n```shell\nerror: the server doesn't have a resource type \"deviceclasses\"\n```\n\nA control plane controller is supported when it is possible to create a `ResourceClaim` where the `spec.controller` field is set. When the `DRAControlPlaneController` feature is disabled, that field automatically gets cleared when storing the `ResourceClaim`.\n\nThe default configuration of kube-scheduler enables the \"DynamicResources\" plugin if and only if the feature gate is enabled and when using the v1 configuration API. Custom configurations may have to be modified to include it.\n\nIn addition to enabling the feature in the cluster, a resource driver also has to be installed. Please refer to the driver's documentation for details.\n\n### Scheduling Details\n\nWhen using a control plane controller, the resource driver handles the allocation of resources in cooperation with the Kubernetes scheduler. The scheduler checks all `ResourceClaims` needed by a pod and creates a `PodSchedulingContext` object, informing the resource drivers about nodes that are considered suitable for the pod. The resource drivers respond by excluding nodes that don't have enough resources left. Once the scheduler has this information, it selects a node and stores the choice in the `PodSchedulingContext` object. The resource drivers then allocate the resources, and the pod gets scheduled. Without a control plane controller, the scheduler uses structured parameters to allocate resources directly from `ResourceSlice` objects, tracking which resources have been allocated and selecting from the remaining resources.\n\n### Monitoring Resources\n\nThe kubelet provides a gRPC service to enable the discovery of dynamic resources for running pods. This service allows resource drivers to report the availability and status of resources on each node. The gRPC endpoints provide detailed information about the resources allocated to each pod, helping administrators monitor and manage resource usage effectively. This monitoring capability is crucial for ensuring that resources are being used efficiently and for troubleshooting any issues that may arise with resource allocation.\n\n### Pre-scheduled Pods\n\nWhen a pod is created with the `spec.nodeName` field already set, the scheduler is bypassed. If the required `ResourceClaims` for the pod do not exist, are not allocated, or are not reserved, the kubelet will fail to run the pod and periodically re-check until the requirements are fulfilled. This situation can occur due to version skew, configuration issues, or feature gate settings. The kube-controller-manager detects such scenarios and attempts to make the pod runnable by triggering the allocation and reservation of the required `ResourceClaims`. However, it is generally better to avoid bypassing the scheduler to prevent resource blocking and ensure efficient resource allocation.\n\n## 🔗 References\n\n- [Kubernetes](https://kubernetes.io/)\n- [Container Storage Interface (CSI)](https://kubernetes-csi.github.io/docs/)\n- [Container Device Interface (CDI)](https://github.com/container-orchestrated-devices/container-device-interface)\n","wordCount":{"words":1425},"frontmatter":{"id":"756800f3b0431ff2663d7cef","path":"/blog/k8s-dynamic-resource-allocation-dra/","humanDate":"Nov 2, 2024","fullDate":"2024-11-02","title":"Dynamic Resource Allocation in Kubernetes","keywords":["Dynamic Resource Allocation","Kubernetes","k8s","Resource Management"],"excerpt":"An in-depth look at Dynamic Resource Allocation (DRA) in Kubernetes and its importance in modern environments","cover":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAADEUlEQVR42i2R7VMSBgCH/UPq5vfdbcOzdvuwtFvl9WJlt3RZtyGkcqS5EqUhkoA2SPIFeTFwgoqHb3k6RRQlQBBwlkOdZClRt9s8P+xudy3r2zPc+geee37PL+uj0A5HQ5vk/+znvGeOK95pRNOj3PSNIPM4UM3aMARtmAJd/BR8gDusY3BWwWy4geBSHeHFKhJxCbvJSvZTIrKyQymOBDfIabNwrKOLAmMnl6wdlLnMVDrbkNo0yAe0NPY3onc3YJ1U8qNVTPdgBRb7t/Q5rzDiKia9Kub9SzFZ/xmGkxTENiiOriD57QnCyUHKBsxU9LYitWuROZvQDB0AFaitUkYX7jI+Y2d1XUM6JWPvZQ1/7Uh5u1P2AbiYAS6ucvFpgpPGOQp1Dm54XdSMP6R2uI2WCSMysw7DmBbTozu45zX4l/VEf9XROrKOP2zm79R1/tn+YPh5pmHeShJln5tzH6s5XtnD3a0wLQkvludT1CwYyM6xoXbZiO/1EEi28+SFBmX/OML2N0z6unn7qow3B8Ds4DY5S1tc9YTwfSdi9NQZ7pg6kXgHaI57UCQM5AYEfKL6mgazmu4FHZGt+zz0OTnR6KFQPYnDN8XedhX7B5OzAy8QxLbRGsyMXbiA3NrDpe9VXFWq0GQMv4ldI9+fzw/Ttyk+dxa9Q4b/mQmJeRhxq50xVzv65sek41W8z1hmHc68nJd52VZ+g67bt7j8eI0jdUucvr+CasPFlzN5SJZvcs+pR3A0l3r1NYZ/cVKoHMTp62THUsqMIJfX/aW8+7OcrEPhNKc9UYzVtdT3OiiJrnGqPYpwNE7tqpkz80Xo1jt48KiNy6KLmIbqsfmdSDsdxDbvkeyvZKW6kN1gBfuvMw0PRV5xdjyAvk5J1cQkJaE1jjVFELoj1Cx3UeQvxfLMibavhYKir+hyy7HM9aBw9LKW0rJuFBESnmA3VP4/8HAkzcmJEE1yFeL5BYq8CQTVIUrsUW7FrBTPibA/H6KuQ85nOZ/SbK7G4u1G3WdhM63hqaIEz/Ev+GPqOu9+F/MvbVZawIwkxMcAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/f9c464255bb43abf243e234b9fbffa4c/befd1/image.png","srcSet":"/static/f9c464255bb43abf243e234b9fbffa4c/3ee9e/image.png 750w,\n/static/f9c464255bb43abf243e234b9fbffa4c/faa1e/image.png 1080w,\n/static/f9c464255bb43abf243e234b9fbffa4c/70643/image.png 1366w,\n/static/f9c464255bb43abf243e234b9fbffa4c/befd1/image.png 1920w","sizes":"100vw"},"sources":[{"srcSet":"/static/f9c464255bb43abf243e234b9fbffa4c/b5c20/image.webp 750w,\n/static/f9c464255bb43abf243e234b9fbffa4c/faf10/image.webp 1080w,\n/static/f9c464255bb43abf243e234b9fbffa4c/7effd/image.webp 1366w,\n/static/f9c464255bb43abf243e234b9fbffa4c/a1f10/image.webp 1920w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5708333333333333}}},"coverCredits":"Photo by Saifeddine Rajhi"}}},"pageContext":{"prevThought":{"frontmatter":{"path":"/blog/integrating-dapr-with-aws-eks/","title":"Speed Up Microservices Development with Dapr on AWS EKS","date":"2024-11-02 18:30:00"},"excerpt":"Use Dapr to Build Distributed Applications Easily on Kubernetes 🎩 🐳 Introduction Building distributed applications means creating software…"},"nextThought":{"frontmatter":{"path":"/blog/topology-aware-routing-kubernetes/","title":"Improve Network Performance with Topology Aware Routing in Amazon EKS ✒","date":"2024-11-01 20:00:00"},"excerpt":"How Topology Aware Routing Can Reduce Costs and Improve Network Performance 🚀 🔖 Introduction  As Kubernetes clusters are increasingly…"}}},"staticQueryHashes":["1271460761","1321585977"],"slicesMap":{}}