{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/kubewatch-kubernetes-observability-monitoring/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p><strong>Real-Time Observability ğŸŒŸ</strong></p>\n</blockquote>\n<h2 id=\"-introduction\" style=\"position:relative;\"><a href=\"#-introduction\" aria-label=\" introduction permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>ğŸ—¯ Introduction</h2>\n<p>Kubernetes is a popular container orchestration platform that automates many of the tasks involved in deploying, managing, and scaling containerized applications. However, Kubernetes can be complex, and it can be difficult to keep track of all the changes that are happening in your cluster.</p>\n<p>This is where Kubewatch comes in. Kubewatch is a Kubernetes watcher that publishes notifications to available collaboration hubs/notification channels. It watches the cluster for resource changes and notifies you through webhooks.</p>\n<p><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 56.470588235294116%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDAQX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB78mRLmC//8QAFxAAAwEAAAAAAAAAAAAAAAAAAAIQEv/aAAgBAQABBQITUa//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAWEAADAAAAAAAAAAAAAAAAAAAAICH/2gAIAQEABj8CKv8A/8QAGxAAAQQDAAAAAAAAAAAAAAAAAQAQETEhYZH/2gAIAQEAAT8hNYRlMWoo2et//9oADAMBAAIAAwAAABAsz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABcRAQADAAAAAAAAAAAAAAAAAAEQESH/2gAIAQIBAT8QHKj/xAAdEAACAQQDAAAAAAAAAAAAAAABESEAEDFBUXHR/9oACAEBAAE/EHfZRWFyMWFjJHRIoTWnn7b/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"kubewatch\" title=\"\" src=\"/static/3e42d1aed4c50a386b35e455743aaf8c/c08c5/kubewatch.jpg\" srcset=\"/static/3e42d1aed4c50a386b35e455743aaf8c/651be/kubewatch.jpg 170w,\n/static/3e42d1aed4c50a386b35e455743aaf8c/d30a3/kubewatch.jpg 340w,\n/static/3e42d1aed4c50a386b35e455743aaf8c/c08c5/kubewatch.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n          </p>\n<h2 id=\"-what-is-kubewatch\" style=\"position:relative;\"><a href=\"#-what-is-kubewatch\" aria-label=\" what is kubewatch permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>ğŸ‘€ What is Kubewatch?</h2>\n<p><a href=\"https://github.com/robusta-dev/kubewatch\" target=\"_blank\" rel=\"noopener noreferrer\">Kubewatch</a> is a Kubernetes watcher that sends notifications to various channels like Slack, Hipchat, and others. It can monitor a wide range of <a href=\"https://www.datadoghq.com/blog/monitor-kubernetes-events/\" target=\"_blank\" rel=\"noopener noreferrer\">Kubernetes events</a>, including pod lifecycle events, deployment status changes, service updates, and more.</p>\n<p>With Kubewatch, you can get real-time notifications when changes occur in your Kubernetes environment, so you can take action immediately.</p>\n<h3 id=\"how-does-kubewatch-work\" style=\"position:relative;\"><a href=\"#how-does-kubewatch-work\" aria-label=\"how does kubewatch work permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>How does Kubewatch work?</h3>\n<p>To understand how Kubewatch works, let's first look at the concept of Kubernetes events. Kubernetes events are objects that help you know what's happening inside your resources (pods, nodes, clusters, and so on). These objects are usually generated in response to changes happening within these resources. By collecting and analyzing these events, you can sneak a peek into the performance and health of your Kubernetes cluster.</p>\n<p>Kubewatch is an open-source events watcher for Kubernetes. You can configure it to watch your Kubernetes clusters for events, collect them, and stream relevant notifications to external services such as Slack. With Kubewatch, you can set up a Slack bot that sends a message in your team channel whenever one of your resources goes down.</p>\n<p>Internally, a kubewatch container is created whenever you run the tool, alongside the kubectl sidecar for communicating with the API server.</p>\n<h3 id=\"-key-features\" style=\"position:relative;\"><a href=\"#-key-features\" aria-label=\" key features permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>ğŸ§© Key Features</h3>\n<ul>\n<li><strong>Simplicity</strong>: Completely open-source with a large community of developers.</li>\n<li><strong>Integration</strong>: Works with various notification channels like Slack, Hipchat, Mattermost, Flock, Webhook, and SMTP.</li>\n<li><strong>Event Monitoring</strong>: Monitors events like pod, deployment, configmap creation, and deletion.</li>\n</ul>\n<h3 id=\"installation\" style=\"position:relative;\"><a href=\"#installation\" aria-label=\"installation permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Installation</h3>\n<p>In this blog, we will use Helm to install Kubewatch and use Slack as the notification medium.</p>\n<h4 id=\"configuring-slack\" style=\"position:relative;\"><a href=\"#configuring-slack\" aria-label=\"configuring slack permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Configuring Slack</h4>\n<ol>\n<li>Go to your Slack workspace, and you have the option to create a new channel, or you can use an existing channel. For this demo, I am going to use an existing channel <code class=\"language-text\">slacktest</code> (but creating a new channel is pretty easy, you need to click on Create a new channel).</li>\n<li>Once you have a Slack channel, the next step is to get a Slack token to integrate with Kubewatch. To create a Slack token, go to <a href=\"https://api.slack.com/apps/new\" target=\"_blank\" rel=\"noopener noreferrer\">Slack API</a> and create a new app. Give your App Name, for example: <code class=\"language-text\">kubewatch</code>, and select your Development Slack Workspace.</li>\n<li>Define your token scope. In this case, we are using <code class=\"language-text\">chat:write</code> as scope which gives permission to post messages in approved channels &#x26; conversations.</li>\n</ol>\n<h4 id=\"setup\" style=\"position:relative;\"><a href=\"#setup\" aria-label=\"setup permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Setup</h4>\n<p>To use Kubewatch, you first need to install it on your Kubernetes cluster. There are a few ways to do this, but the simplest method is to use Helm. Here's how you can install Kubewatch with Helm:</p>\n<ol>\n<li><strong>Install Helm</strong> on your machine if you haven't already done so.</li>\n<li><strong>Add the Kubewatch repository to Helm</strong>:\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">helm repo <span class=\"token function\">add</span> robusta https://robusta-charts.storage.googleapis.com</code></pre></div>\n</li>\n<li><strong>Update your Helm repository</strong>:\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">helm repo update</code></pre></div>\nUpdate Complete. âˆHappy Helming!âˆ</li>\n<li><strong>Install Kubewatch</strong>:\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">helm <span class=\"token function\">install</span> kubewatch robusta/kubewatch</code></pre></div>\n</li>\n</ol>\n<p>As we know all Helm charts come with a default set of values but in this case, we want to modify these values according to our requirement.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">helm show values robusta/kubewatch <span class=\"token operator\">></span> ~/kubewatch.yaml</code></pre></div>\n<p>Now, please open this file and make modifications to a few parameters. Let's begin with Slack by adding the channel where notifications should be sent and inserting the token that we generated during the Slack section:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">slack</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">enabled</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n  <span class=\"token comment\"># Slack channel to notify</span>\n  <span class=\"token key atrule\">channel</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"slacktest\"</span>\n  <span class=\"token comment\"># Slack bots token. Create using: https://my.slack.com/services/new/bot</span>\n  <span class=\"token comment\"># and invite the bot to your channel using: /join @botname</span>\n  <span class=\"token key atrule\">token</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"xoxb-XXXXXXX\"</span></code></pre></div>\n<p>In the next step, we need to define what we want to monitor. In this case, we want to monitor only the events from the default namespace (<code class=\"language-text\">namespaceToWatch: \"default\"</code>) and the resources to watch (deployment, services, pod). If you wish to monitor any other resources, simply change the corresponding parameter to true. For example, you can change <code class=\"language-text\">replicaset: false</code> to <code class=\"language-text\">replicaset: true</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">namespaceToWatch</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"default\"</span>\n<span class=\"token key atrule\">resourcesToWatch</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">deployment</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span>\n  <span class=\"token key atrule\">replicationcontroller</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span>\n  <span class=\"token key atrule\">replicaset</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span>\n  <span class=\"token key atrule\">daemonset</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span>\n  <span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n  <span class=\"token key atrule\">pod</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n  <span class=\"token key atrule\">job</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span>\n  <span class=\"token key atrule\">node</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span>\n  <span class=\"token key atrule\">clusterrole</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n  <span class=\"token key atrule\">clusterrolebinding</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n  <span class=\"token key atrule\">serviceaccount</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n  <span class=\"token key atrule\">persistentvolume</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span>\n  <span class=\"token key atrule\">namespace</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span>\n  <span class=\"token key atrule\">secret</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span>\n  <span class=\"token key atrule\">configmap</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span>\n  <span class=\"token key atrule\">ingress</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span>\n  <span class=\"token key atrule\">coreevent</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span>\n  <span class=\"token key atrule\">event</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span></code></pre></div>\n<p>One crucial parameter to configure is <code class=\"language-text\">rbac</code>, which should be set to 'true.' If left at its default value of 'false,' the service account created by this Helm chart won't have the necessary permissions to list Kubernetes resources, such as pods, deployments, services, and more.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">rbac</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">create</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span></code></pre></div>\n<p>With all the configuration in place, it is time to deploy the Helm chart with our customized values:</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">helm upgrade kubewatch robusta/kubewatch <span class=\"token parameter variable\">--values</span> ~/kubewatch.yaml</code></pre></div>\n<p><strong>Please be patient while the chart is being deployed</strong></p>\n<h3 id=\"testing\" style=\"position:relative;\"><a href=\"#testing\" aria-label=\"testing permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Testing</h3>\n<p>Try to create any pod in the default namespace:</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">kubectl run nginx2 <span class=\"token parameter variable\">--image</span><span class=\"token operator\">=</span>nginx</code></pre></div>\n<p>Pod created:</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">pod/nginx2 created</code></pre></div>\n<p>If you go to the Slack channel, you will see a notification like this:</p>\n<p><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 24.705882352941178%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAlElEQVR42pWQXQrDMAyDc//z7edhMFiZIVsZLCR2kzip6nYXWATCDxYfsl24nXC+XkBPAjNDS0Gp1WZF7x3rug7ZSWZ4IsRvwCICTYJk4JIYXfVv0C61vGuaMU93zP4NETYLSkw/mIVGgMWuM+CC+WFA8kfDnDOqza5t6NRd1V51NAw04UMvpBjB1jKHiGbL4YZJsAFoL4gj8mMOTAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"notif\" title=\"\" src=\"/static/5c734b90388019c42641a58e037ea21d/c5bb3/notif1.png\" srcset=\"/static/5c734b90388019c42641a58e037ea21d/04472/notif1.png 170w,\n/static/5c734b90388019c42641a58e037ea21d/9f933/notif1.png 340w,\n/static/5c734b90388019c42641a58e037ea21d/c5bb3/notif1.png 680w,\n/static/5c734b90388019c42641a58e037ea21d/b12f7/notif1.png 1020w,\n/static/5c734b90388019c42641a58e037ea21d/b5a09/notif1.png 1360w,\n/static/5c734b90388019c42641a58e037ea21d/29007/notif1.png 1600w\" sizes=\"(max-width: 680px) 100vw, 680px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n          </p>\n<h3 id=\"wrapping-up\" style=\"position:relative;\"><a href=\"#wrapping-up\" aria-label=\"wrapping up permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Wrapping Up</h3>\n<p>In conclusion, Kubewatch is a potent tool that delivers notifications for all events within your Kubernetes cluster. However, it's important to configure it thoughtfully, as an excessive number of notifications in a busy cluster can result in notification fatigue, potentially causing you to overlook critical alerts.</p>\n<blockquote>\n<p><strong>If you found this article helpful, please don't forget to hit the Follow ğŸ‘‰ and Clap ğŸ‘ buttons to help me write more articles like this.</strong></p>\n</blockquote>\n<p><strong>Thank YouÂ ğŸ–¤</strong></p>\n<br>\n<p><strong><em>Until next time, ã¤ã¥ã ğŸ‰</em></strong></p>\n<blockquote>\n<p>ğŸ’¡ Thank you for Reading !! ğŸ™ŒğŸ»ğŸ˜ğŸ“ƒ, see you in the next blog.ğŸ¤˜  <strong><em>Until next time ğŸ‰</em></strong></p>\n</blockquote>\n<p>ğŸš€ Thank you for sticking up till the end. If you have any questions/feedback regarding this blog feel free to connect with me:</p>\n<p><strong>â™»ï¸ LinkedIn:</strong> <a href=\"https://www.linkedin.com/in/rajhi-saif/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.linkedin.com/in/rajhi-saif/</a></p>\n<p><strong>â™»ï¸ X/Twitter:</strong> <a href=\"https://x.com/rajhisaifeddine\" target=\"_blank\" rel=\"noopener noreferrer\">https://x.com/rajhisaifeddine</a></p>\n<p><strong>The end âœŒğŸ»</strong></p>\n<h1 align=\"center\">ğŸ”° Keep Learning !! Keep Sharing !! ğŸ”°</h1>\n<p><strong>ğŸ“… Stay updated</strong></p>\n<p>Subscribe to our newsletter for more insights on AWS cloud computing and containers.</p>","timeToRead":4,"rawMarkdownBody":"\n> **Real-Time Observability ğŸŒŸ**\n\n## ğŸ—¯ Introduction\n\nKubernetes is a popular container orchestration platform that automates many of the tasks involved in deploying, managing, and scaling containerized applications. However, Kubernetes can be complex, and it can be difficult to keep track of all the changes that are happening in your cluster.\n\nThis is where Kubewatch comes in. Kubewatch is a Kubernetes watcher that publishes notifications to available collaboration hubs/notification channels. It watches the cluster for resource changes and notifies you through webhooks.\n\n![kubewatch](./kubewatch.jpg)\n\n## ğŸ‘€ What is Kubewatch?\n\n[Kubewatch](https://github.com/robusta-dev/kubewatch) is a Kubernetes watcher that sends notifications to various channels like Slack, Hipchat, and others. It can monitor a wide range of [Kubernetes events](https://www.datadoghq.com/blog/monitor-kubernetes-events/), including pod lifecycle events, deployment status changes, service updates, and more.\n\nWith Kubewatch, you can get real-time notifications when changes occur in your Kubernetes environment, so you can take action immediately.\n\n### How does Kubewatch work?\n\nTo understand how Kubewatch works, let's first look at the concept of Kubernetes events. Kubernetes events are objects that help you know what's happening inside your resources (pods, nodes, clusters, and so on). These objects are usually generated in response to changes happening within these resources. By collecting and analyzing these events, you can sneak a peek into the performance and health of your Kubernetes cluster.\n\nKubewatch is an open-source events watcher for Kubernetes. You can configure it to watch your Kubernetes clusters for events, collect them, and stream relevant notifications to external services such as Slack. With Kubewatch, you can set up a Slack bot that sends a message in your team channel whenever one of your resources goes down.\n\nInternally, a kubewatch container is created whenever you run the tool, alongside the kubectl sidecar for communicating with the API server.\n\n### ğŸ§© Key Features\n\n- **Simplicity**: Completely open-source with a large community of developers.\n- **Integration**: Works with various notification channels like Slack, Hipchat, Mattermost, Flock, Webhook, and SMTP.\n- **Event Monitoring**: Monitors events like pod, deployment, configmap creation, and deletion.\n\n### Installation\n\nIn this blog, we will use Helm to install Kubewatch and use Slack as the notification medium.\n\n#### Configuring Slack\n\n1. Go to your Slack workspace, and you have the option to create a new channel, or you can use an existing channel. For this demo, I am going to use an existing channel `slacktest` (but creating a new channel is pretty easy, you need to click on Create a new channel).\n2. Once you have a Slack channel, the next step is to get a Slack token to integrate with Kubewatch. To create a Slack token, go to [Slack API](https://api.slack.com/apps/new) and create a new app. Give your App Name, for example: `kubewatch`, and select your Development Slack Workspace.\n3. Define your token scope. In this case, we are using `chat:write` as scope which gives permission to post messages in approved channels & conversations.\n\n#### Setup\n\nTo use Kubewatch, you first need to install it on your Kubernetes cluster. There are a few ways to do this, but the simplest method is to use Helm. Here's how you can install Kubewatch with Helm:\n\n1. **Install Helm** on your machine if you haven't already done so.\n2. **Add the Kubewatch repository to Helm**:\n    ```sh\n    helm repo add robusta https://robusta-charts.storage.googleapis.com\n    ```\n3. **Update your Helm repository**:\n    ```sh\n    helm repo update\n    ```\n    Update Complete. âˆHappy Helming!âˆ\n4. **Install Kubewatch**:\n    ```sh\n    helm install kubewatch robusta/kubewatch\n    ```\n\nAs we know all Helm charts come with a default set of values but in this case, we want to modify these values according to our requirement.\n\n```sh\nhelm show values robusta/kubewatch > ~/kubewatch.yaml\n```\n\nNow, please open this file and make modifications to a few parameters. Let's begin with Slack by adding the channel where notifications should be sent and inserting the token that we generated during the Slack section:\n\n```yaml\nslack:\n  enabled: true\n  # Slack channel to notify\n  channel: \"slacktest\"\n  # Slack bots token. Create using: https://my.slack.com/services/new/bot\n  # and invite the bot to your channel using: /join @botname\n  token: \"xoxb-XXXXXXX\"\n```\n\nIn the next step, we need to define what we want to monitor. In this case, we want to monitor only the events from the default namespace (`namespaceToWatch: \"default\"`) and the resources to watch (deployment, services, pod). If you wish to monitor any other resources, simply change the corresponding parameter to true. For example, you can change `replicaset: false` to `replicaset: true`.\n\n```yaml\nnamespaceToWatch: \"default\"\nresourcesToWatch:\n  deployment: false\n  replicationcontroller: false\n  replicaset: false\n  daemonset: false\n  services: true\n  pod: true\n  job: false\n  node: false\n  clusterrole: true\n  clusterrolebinding: true\n  serviceaccount: true\n  persistentvolume: false\n  namespace: false\n  secret: false\n  configmap: false\n  ingress: false\n  coreevent: false\n  event: true\n```\n\nOne crucial parameter to configure is `rbac`, which should be set to 'true.' If left at its default value of 'false,' the service account created by this Helm chart won't have the necessary permissions to list Kubernetes resources, such as pods, deployments, services, and more.\n\n```yaml\nrbac:\n  create: true\n```\n\nWith all the configuration in place, it is time to deploy the Helm chart with our customized values:\n\n```sh\nhelm upgrade kubewatch robusta/kubewatch --values ~/kubewatch.yaml\n```\n\n**Please be patient while the chart is being deployed**\n\n### Testing\n\nTry to create any pod in the default namespace:\n\n```sh\nkubectl run nginx2 --image=nginx\n```\n\nPod created:\n\n```sh\npod/nginx2 created\n```\n\nIf you go to the Slack channel, you will see a notification like this:\n\n![notif](./notif1.png)\n\n### Wrapping Up\n\nIn conclusion, Kubewatch is a potent tool that delivers notifications for all events within your Kubernetes cluster. However, it's important to configure it thoughtfully, as an excessive number of notifications in a busy cluster can result in notification fatigue, potentially causing you to overlook critical alerts.\n\n> **If you found this article helpful, please don't forget to hit the Follow ğŸ‘‰ and Clap ğŸ‘ buttons to help me write more articles like this.**\n\n**Thank YouÂ ğŸ–¤**\n\n<br>\n\n**_Until next time, ã¤ã¥ã ğŸ‰_**\n\n> ğŸ’¡ Thank you for Reading !! ğŸ™ŒğŸ»ğŸ˜ğŸ“ƒ, see you in the next blog.ğŸ¤˜  **_Until next time ğŸ‰_**\n\nğŸš€ Thank you for sticking up till the end. If you have any questions/feedback regarding this blog feel free to connect with me:\n\n**â™»ï¸ LinkedIn:** https://www.linkedin.com/in/rajhi-saif/\n\n**â™»ï¸ X/Twitter:** https://x.com/rajhisaifeddine\n\n**The end âœŒğŸ»**\n\n<h1 align=\"center\">ğŸ”° Keep Learning !! Keep Sharing !! ğŸ”°</h1>\n\n**ğŸ“… Stay updated**\n\nSubscribe to our newsletter for more insights on AWS cloud computing and containers.\n","wordCount":{"words":883},"frontmatter":{"id":"7175cbb1c966a220782539c6","path":"/blog/kubewatch-kubernetes-observability-monitoring/","humanDate":"Oct 24, 2024","fullDate":"2024-10-24","title":"Kubewatch: A Kubernetes Watcher for Observability and Monitoring","keywords":["Kubernetes","Observability","Monitoring","Kubewatch"],"excerpt":"Discover how Kubewatch enhances Kubernetes observability and monitoring with real-time insights and alerts.","cover":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAABAAC/8QAFgEBAQEAAAAAAAAAAAAAAAAAAwEC/9oADAMBAAIQAxAAAAEyQSa1Eq//xAAbEAACAQUAAAAAAAAAAAAAAAAAARECEhMiMf/aAAgBAQABBQLhl1qam5wxn//EABgRAAMBAQAAAAAAAAAAAAAAAAABAhEx/9oACAEDAQE/AautFazh/8QAGREAAwADAAAAAAAAAAAAAAAAAAERAjFR/9oACAECAQE/AXjdkfT/xAAbEAABBAMAAAAAAAAAAAAAAAARAAECECFBgf/aAAgBAQAGPwIOyjjVErlf/8QAGRABAAMBAQAAAAAAAAAAAAAAAQARIUFh/9oACAEBAAE/IfU2yU2GrLj7kHSVnZghbP/aAAwDAQACAAMAAAAQ18//xAAXEQEBAQEAAAAAAAAAAAAAAAABEQBB/9oACAEDAQE/EKJe4Qou/8QAFxEAAwEAAAAAAAAAAAAAAAAAAAERMf/aAAgBAgEBPxBECWMf/8QAGhABAQEBAQEBAAAAAAAAAAAAAREAIVGx8P/aAAgBAQABPxAW+IiEFQ7812bQiGjDMqFOnjkgCAXWfnJWQvj0zX3f/9k="},"images":{"fallback":{"src":"/static/4aa6580166c8a844b601e7b706c0a869/1e21a/kubewatch-cover.jpg","srcSet":"/static/4aa6580166c8a844b601e7b706c0a869/37bba/kubewatch-cover.jpg 750w,\n/static/4aa6580166c8a844b601e7b706c0a869/1e21a/kubewatch-cover.jpg 800w","sizes":"100vw"},"sources":[{"srcSet":"/static/4aa6580166c8a844b601e7b706c0a869/a66aa/kubewatch-cover.webp 750w,\n/static/4aa6580166c8a844b601e7b706c0a869/b2a35/kubewatch-cover.webp 800w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5625}}},"coverCredits":"Photo by Saifeddine Rajhi"}}},"pageContext":{"prevThought":{"frontmatter":{"path":"/blog/goodbye-ingress-gateway-api-cilium/","title":"Saying Goodbye to Ingress: Embracing the Future of Kubernetes Traffic Management with Gateway API and Cilium","date":"2024-10-24 14:34:00"},"excerpt":"Transitioning from ingress to Gateway API and Cilium for modern traffic management â˜¸ï¸ Introduction In the dynamic world of Kubernetesâ€¦","html":"<blockquote>\n<p><strong>Transitioning from ingress to Gateway API and Cilium for modern traffic management</strong></p>\n</blockquote>\n<h2 id=\"ï¸-introduction\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-introduction\" aria-label=\"ï¸ introduction permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>â˜¸ï¸ Introduction</h2>\n<p>In the dynamic world of Kubernetes, managing ingress traffic efficiently and securely has always been a crucial challenge. However, a groundbreaking solution has emerged, promising to transform the way we handle traffic routing within Kubernetes clusters. Meet the <a href=\"https://gateway-api.sigs.k8s.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Gateway API</a>: a long-term replacement for Kubernetes Ingress that brings a wealth of benefits to operators, including role-based access control, portability, and extensibility.</p>\n<h2 id=\"-goals--objectives\" style=\"position:relative;\"><a href=\"#-goals--objectives\" aria-label=\" goals  objectives permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>ğŸ¯ Goals &#x26; Objectives</h2>\n<p>In this article, we will delve into the innovative capabilities of Gateway API and explore why it is poised to revolutionize Kubernetes traffic management. <strong>HAPPY LEARNING ğŸ’»</strong></p>\n<h2 id=\"ï¸-unveiling-the-gateway-api\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-unveiling-the-gateway-api\" aria-label=\"ï¸ unveiling the gateway api permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>â¡ï¸ Unveiling the Gateway API</h2>\n<p><a href=\"https://gateway-api.sigs.k8s.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Gateway API</a> is an open-source project managed by the SIG-NETWORK community. It is a collection of resources that model service networking in Kubernetes. These resourcesâ€Šâ€”â€ŠGatewayClass, Gateway, HTTPRoute, TCPRoute, Service, etc.â€Šâ€”â€Šaim to evolve Kubernetes service networking through expressive, extensible, and role-oriented interfaces that are implemented by many vendors and have broad industry support.</p>\n<p>Originally conceived as a successor to the well-known Ingress API, the benefits of Gateway API include (but are not limited to) explicit support for many commonly used networking protocols (e.g., HTTP, TLS, TCP, UDP) as well as tightly integrated support for Transport Layer Security (TLS). The Gateway resource, in particular, enables implementations to manage the lifecycle of network gateways as a Kubernetes API.</p>\n<p><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 58.82352941176471%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABfUlEQVR42oVSy07DQAzM/38NN5B6hUqIcuFAoXBpsyXqpk2aR/NoNhkypg4RpaolS/buejxjrwd0oLlygyqew9Wp5HVd43A4IM9z8bIs0XUd0jRFFEXIsgxJkmC/3yOOY/Hj8QiPj2jWvGL+eIMkNJJnWYowDGGMQRAEUty2rQCOQRhvt1u5J5aHk6VZjqVvUPXMaNqoqioB0jOyUzDGBNK8aZpfwMCsYNdLONcMkglGBkVRDMBkY60VMPputxOnXGGoTO4mU0zvn/pZ/RSyM+fk+75IZzxm+tfVBoZx0hd/bYYLPiIAl0GGXAzzcfF/5o3nFVkfq88X2buCUTrBuBguSLd5EbBrHZqqkGTx/oHZ7Bl1X0AQzk8Z0nVeHL7KPwMMgzUeJreStM7J8FlMMLIiIM+ogrEugg0JfAZobYj520JksKtz7fB5CcpiynZ9MzYiKD88Y56dSz5tiZd8yG2qVDIjE85NZev7i5I1ICCL9bMqAJ1/j6zZ5Jp9A5pKovMw6GB3AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Gateway API\" title=\"\" src=\"/static/fb9b8803f071cc3f55fd677523c15ca6/c5bb3/gw.png\" srcset=\"/static/fb9b8803f071cc3f55fd677523c15ca6/04472/gw.png 170w,\n/static/fb9b8803f071cc3f55fd677523c15ca6/9f933/gw.png 340w,\n/static/fb9b8803f071cc3f55fd677523c15ca6/c5bb3/gw.png 680w,\n/static/fb9b8803f071cc3f55fd677523c15ca6/b12f7/gw.png 1020w,\n/static/fb9b8803f071cc3f55fd677523c15ca6/b5a09/gw.png 1360w,\n/static/fb9b8803f071cc3f55fd677523c15ca6/29007/gw.png 1600w\" sizes=\"(max-width: 680px) 100vw, 680px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n          </p>\n<h2 id=\"-realizing-efficiency-gateway-api-as-the-long-term-solution\" style=\"position:relative;\"><a href=\"#-realizing-efficiency-gateway-api-as-the-long-term-solution\" aria-label=\" realizing efficiency gateway api as the long term solution permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>ğŸš€ Realizing Efficiency: Gateway API as the Long-Term Solution</h2>\n<p>What we keep hearing from users is that they are facing a tool sprawl: when deploying complex micro-services architecture, operators have typically needed to deploy a CNI, a Network Policy engine, a Service Mesh for observability or for encryption, an Ingress or Gateway API controller, etc. This can become an operational headache to upgrade and manage.</p>\n<p><a href=\"https://cilium.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Cilium</a> enables users to consolidate the number of cloud-native networking and security tools they haveâ€Šâ€”â€Šbecause Cilium natively supports not just Gateway API but the Sidecar-less <a href=\"https://isovalent.com/blog/post/cilium-service-mesh/\" target=\"_blank\" rel=\"noopener noreferrer\">Service Mesh</a>, <a href=\"https://isovalent.com/blog/post/tutorial-transparent-encryption-with-ipsec-and-wireguard/\" target=\"_blank\" rel=\"noopener noreferrer\">Transparent Encryption</a>, Network Policies, built-in observability with Hubble, etc.</p>\n<p><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 37.05882352941176%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsTAAALEwEAmpwYAAABMklEQVR42k2QT0vDQBDF87317sWvIHjzIpRCoSAUwVaptaitqR6ssQ02JtnN/p/ZbWvBMbFQ+LEMw868eS9SzhPS4r7wzvtJYrtjKww2yPoDIeh1dWGwMhA1M9vNxvm1gqBcCJsQJ6p9J6xfOx8shqIyZSXi1B63UWjbfrRnfTQAkYYgLXQni/cV145WQspwOLeV0mmpFqUlMqZoxbIwrRFTDsZz3XsR2tXKTJrT1s3wNeHKCK36b+roUuYSe6Np73l5HWcZp+G1Rb/bYX2a3/4g1xAVQq+Kipfld8EzJumQnKvPr5ws3E7ng9nqIalI2ThclHhxDwZw9AFXMf4raxckNIZ9gybA180/SmmYELNUn3SMNLbzZM4HzsI+sEMocHJP5g+hPpcmZ6zSQHFQfkLDL6w4gKuTz/fXAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Cilium\" title=\"\" src=\"/static/1a084acdc37cc16dfe9346401ad402eb/c5bb3/cilium.png\" srcset=\"/static/1a084acdc37cc16dfe9346401ad402eb/04472/cilium.png 170w,\n/static/1a084acdc37cc16dfe9346401ad402eb/9f933/cilium.png 340w,\n/static/1a084acdc37cc16dfe9346401ad402eb/c5bb3/cilium.png 680w,\n/static/1a084acdc37cc16dfe9346401ad402eb/5a190/cilium.png 800w\" sizes=\"(max-width: 680px) 100vw, 680px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n          </p>\n<h2 id=\"ï¸-intro-to-cilium\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-intro-to-cilium\" aria-label=\"ï¸ intro to cilium permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>ğŸ› ï¸ Intro to Cilium</h2>\n<p>Cilium stands out among the various Container Network Interfaces (CNI) available for Kubernetes. Built around eBPF (extended Berkeley Packet Filter), Cilium focuses on networking, observability, and security within Kubernetes networking. While it provides standard networking functionalities like assigning CIDRs to Pods and enabling communication between them, the key distinction lies in its eBPF backend. By leveraging eBPF's capabilities, such as hash tables, Cilium eliminates the need for kube-proxy and IP Tables, offering improved efficiency and performance in managing network operations.</p>\n<p><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 66.47058823529413%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMBAgX/xAAVAQEBAAAAAAAAAAAAAAAAAAACAP/aAAwDAQACEAMQAAABlSLC0hAV/8QAGRAAAwEBAQAAAAAAAAAAAAAAAQMSAiEA/9oACAEBAAEFAmug6czJBoOT2I8rmP/EABURAQEAAAAAAAAAAAAAAAAAABAh/9oACAEDAQE/Aaf/xAAWEQADAAAAAAAAAAAAAAAAAAABEBH/2gAIAQIBAT8BEX//xAAaEAACAwEBAAAAAAAAAAAAAAAAARESIXEx/9oACAEBAAY/AqpSzUtJJs2e26dP/8QAHBAAAgICAwAAAAAAAAAAAAAAAREAMSFhQVFx/9oACAEBAAE/IehYmYJpimopAyw9kzI0cKgp2c//2gAMAwEAAgADAAAAEOw//8QAFhEBAQEAAAAAAAAAAAAAAAAAAQAx/9oACAEDAQE/EETsZf/EABcRAAMBAAAAAAAAAAAAAAAAAAABETH/2gAIAQIBAT8Qgh6f/8QAHhABAAICAQUAAAAAAAAAAAAAAREhAEFhUXGBkaH/2gAIAQEAAT8Qk+GgK6yZa7jPITrhyEJ6dmUkz3uVbYRd4XWTCWyAsGo+Z//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Cilium Sidecar\" title=\"\" src=\"/static/58080c17056dad5acdc0d94aa05c4c32/7bf67/sidecar.jpg\" srcset=\"/static/58080c17056dad5acdc0d94aa05c4c32/651be/sidecar.jpg 170w,\n/static/58080c17056dad5acdc0d94aa05c4c32/d30a3/sidecar.jpg 340w,\n/static/58080c17056dad5acdc0d94aa05c4c32/7bf67/sidecar.jpg 680w,\n/static/58080c17056dad5acdc0d94aa05c4c32/990cb/sidecar.jpg 1020w,\n/static/58080c17056dad5acdc0d94aa05c4c32/eea4a/sidecar.jpg 1280w\" sizes=\"(max-width: 680px) 100vw, 680px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n          </p>\n<h2 id=\"-cilium-gateway-api\" style=\"position:relative;\"><a href=\"#-cilium-gateway-api\" aria-label=\" cilium gateway api permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>ğŸŒ Cilium Gateway API</h2>\n<p>Cilium has now incorporated support for Gateway API, marking a significant milestone! Gateway API serves as the future replacement for Kubernetes Ingress, offering operators a role-based, portable, and extensible approach to efficiently route traffic within their clusters.</p>\n<p>Cilium introduces a range of exciting features. It offers a fully-conformant implementation of Gateway API, providing users with a flexible and powerful approach to traffic routing. Additionally, there are new annotations available for configuring L7 load-balancing, including per-request gRPC balancing. The release also includes the merged mTLS datapath, setting the stage for a future proxy-free mTLS implementation that can integrate with various identity management providers. Networking enhancements such as BIG TCP, IPAM for LoadBalancer Kubernetes Services, SCTP support, and NAT46/64 improvements have been implemented. Security has been strengthened through image signing and the creation of Software Bill of Materials (SBOMs). NetworkPolicy now supports matching TLS SNI server names. The partnership between Isovalent and Grafana brings improved network traffic insights and enriched tracing data for Grafana users.</p>\n<p><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 52.352941176470594%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABtElEQVR42i1QSXPbIBj1b++x1/yVXjo99NR07GyNY8eJ5bGRBAgkJGsDsVMk5w3MsMxbvrcKIZBOf8I6gWVS9ACzFFXFdWSDlNo456wYteDKGKWVVBFSTZM2xlq7it/Chv3bw+Pvn1r06QwwDn0IzloTpQM6+5p2I88AsN4HKUKytc5prVfxOkqbwwKk6bWEx+R0vly6tmkYJaQ0xjhrlJST0Tku+mGY5aJqDKJmsp9MSMHH6XUziqlmzC6Roq9Wyi/OhmIewre77w/rP/HBO7eQ1Ux2Iez2u+f1ui3zLNkfP96TzwM6H3KIjDVeTYrzyfjN9oVgFBZ8keNpmnuYlORlxWhJ4zxR8eZv4+gkFyWVvGe0QLhACAkh9IK5sMj/93L/99ePpiwIzOqSgDTr+74hOalYIKkkhDfk9Wnz+PS83b7BmMiYW2E+GlVVTRBqCGhKWOSn98OO89FILkQcNmgd1NDBHGCM/GJml87m2G5BVGlbh6CFmUXQUSTA5QqzAaVtcqzjAqArsGrqyFoadW51KyAy4xbCs8pRYilxba0wbikd62rEuEOoxbhnlebjl1MI4T/92DHsowHwTgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Cilium Features\" title=\"\" src=\"/static/204c2843f539f3d6d624d178beba2cef/c5bb3/features.png\" srcset=\"/static/204c2843f539f3d6d624d178beba2cef/04472/features.png 170w,\n/static/204c2843f539f3d6d624d178beba2cef/9f933/features.png 340w,\n/static/204c2843f539f3d6d624d178beba2cef/c5bb3/features.png 680w,\n/static/204c2843f539f3d6d624d178beba2cef/5a190/features.png 800w\" sizes=\"(max-width: 680px) 100vw, 680px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n          </p>\n<p>As we conclude our exploration of the Gateway API, we highlight its significance as the long-term replacement for Kubernetes Ingress. With its role-based access control, portability, and extensibility, Gateway API is set to redefine how we handle traffic routing within Kubernetes clusters, enabling operators to unleash the full potential of their deployments.</p>\n<h2 id=\"-conclusion-\" style=\"position:relative;\"><a href=\"#-conclusion-\" aria-label=\" conclusion  permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>ğŸŒŸ Conclusion ğŸŒŸ</h2>\n<p>It's time to embrace the future of Kubernetes traffic management. Don't miss out on the revolution. Dive into the Gateway API and unlock the power to route traffic with unparalleled control, security, and flexibility. The era of optimized traffic management within Kubernetes clusters has arrived.</p>\n<blockquote>\n<p>If you found this article helpful, please don't forget to hit the Follow ğŸ‘‰ and Clap ğŸ‘ buttons to help me write more articles like this.</p>\n</blockquote>\n<p><strong>Thank You ğŸ–¤</strong></p>\n<br>\n<p><strong><em>Until next time, ã¤ã¥ã ğŸ‰</em></strong></p>\n<blockquote>\n<p>ğŸ’¡ Thank you for Reading !! ğŸ™ŒğŸ»ğŸ˜ğŸ“ƒ, see you in the next blog.ğŸ¤˜  <strong><em>Until next time ğŸ‰</em></strong></p>\n</blockquote>\n<p>ğŸš€ Thank you for sticking up till the end. If you have any questions/feedback regarding this blog feel free to connect with me:</p>\n<p><strong>â™»ï¸ LinkedIn:</strong> <a href=\"https://www.linkedin.com/in/rajhi-saif/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.linkedin.com/in/rajhi-saif/</a></p>\n<p><strong>â™»ï¸ X/Twitter:</strong> <a href=\"https://x.com/rajhisaifeddine\" target=\"_blank\" rel=\"noopener noreferrer\">https://x.com/rajhisaifeddine</a></p>\n<p><strong>The end âœŒğŸ»</strong></p>\n<h1 align=\"center\">ğŸ”° Keep Learning !! Keep Sharing !! ğŸ”°</h1>\n<p><strong>ğŸ“… Stay updated</strong></p>\n<p>Subscribe to our newsletter for more insights on AWS cloud computing and containers.</p>"},"nextThought":{"frontmatter":{"path":"/blog/docker-layers-efficient-image-management/","title":"Docker Layers: The Secret to Efficient Image Management","date":"2024-10-24 12:06:00"},"excerpt":"Your Way to Individual Docker LayersğŸ³ğŸ”¥ ğŸ“” Introduction Container registries have revolutionized the way developers manage and distributeâ€¦","html":"<blockquote>\n<p><strong>Your Way to Individual Docker LayersğŸ³ğŸ”¥</strong></p>\n</blockquote>\n<h2 id=\"-introduction\" style=\"position:relative;\"><a href=\"#-introduction\" aria-label=\" introduction permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>ğŸ“” Introduction</h2>\n<p>Container registries have revolutionized the way developers manage and distribute containerized applications. Among their many benefits, one standout feature is the ability to pull individual layers, eliminating the need to download entire images.</p>\n<p>In this blog, we'll delve into the fascinating world of container registries, exploring the technical intricacies of layer retrieval and uncovering additional methods and pro tips to optimize your container workflow. Moreover, we will discover how to find the layer with your desired file using tools like <a href=\"https://github.com/wagoodman/dive\" target=\"_blank\" rel=\"noopener noreferrer\">Dive</a> and a web interface like <a href=\"https://explore.ggcr.dev\" target=\"_blank\" rel=\"noopener noreferrer\">explore.ggcr.dev</a>.</p>\n<h3 id=\"-efficient-layer-retrieval\" style=\"position:relative;\"><a href=\"#-efficient-layer-retrieval\" aria-label=\" efficient layer retrieval permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>ğŸš€ Efficient Layer Retrieval</h3>\n<p>Container registries store container images as a collection of layers, with each layer representing a specific filesystem change. To retrieve a specific layer efficiently, you can leverage the Container Registry API, which provides endpoints for authentication, image information, and blob retrieval. The following command obtains an authentication token:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">token</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-silent</span> <span class=\"token string\">\"https://auth.docker.io/token?scope=repository:raesene/alpine-containertools:pull&amp;service=registry.docker.io\"</span> <span class=\"token operator\">|</span> jq <span class=\"token parameter variable\">-r</span> <span class=\"token string\">'.token'</span><span class=\"token variable\">)</span></span></code></pre></div>\n<p>Next, use the token with <code class=\"language-text\">curl</code> to download the specific layer, which is essentially a tar.gz file:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-s</span> <span class=\"token parameter variable\">-L</span> <span class=\"token parameter variable\">-H</span> <span class=\"token string\">\"Authorization: Bearer <span class=\"token variable\">$token</span>\"</span> https://index.docker.io/v2/raesene/alpine-containertools/blobs/sha256:7d342c4ec940e366e2762044134c6e88075cad0b06ef205217725b6212ea4116 <span class=\"token parameter variable\">-o</span> kubectl.tar.gz</code></pre></div>\n<h3 id=\"-digest-based-fetching\" style=\"position:relative;\"><a href=\"#-digest-based-fetching\" aria-label=\" digest based fetching permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>ğŸ” Digest-Based Fetching</h3>\n<p>Aside from using the SHA256 hash of a layer to fetch it, you can also use image digests for data integrity. Image digests are unique identifiers for container images, calculated based on the content of their layers. Fetching an image using its digest guarantees that you get the exact image you want, even if tags or other references change over time:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-s</span> <span class=\"token parameter variable\">-L</span> <span class=\"token parameter variable\">-H</span> <span class=\"token string\">\"Authorization: Bearer <span class=\"token variable\">$token</span>\"</span> https://index.docker.io/v2/raesene/alpine-containertools/blobs/digest:sha256:7d342c4ec940e366e2762044134c6e88075cad0b06ef205217725b6212ea4116</code></pre></div>\n<h3 id=\"-pro-tip-cached-layer-retrieval\" style=\"position:relative;\"><a href=\"#-pro-tip-cached-layer-retrieval\" aria-label=\" pro tip cached layer retrieval permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>ğŸ’¡ Pro Tip: Cached Layer Retrieval</h3>\n<p>Consider setting up a caching mechanism to store frequently accessed layers locally when working with container registries. Tools like <a href=\"https://github.com/containers/skopeo\" target=\"_blank\" rel=\"noopener noreferrer\">Skopeo</a> can help you implement caching, reducing network round trips and speeding up the container image retrieval process.</p>\n<h3 id=\"-exploring-layers-dive-and-beyond\" style=\"position:relative;\"><a href=\"#-exploring-layers-dive-and-beyond\" aria-label=\" exploring layers dive and beyond permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>ğŸ” Exploring Layersâ€Š-â€ŠDive and Beyond</h3>\n<p>In addition to fetching specific layers, let's explore more options for exploring container image layers:</p>\n<ul>\n<li><a href=\"https://docs.docker.com/engine/reference/commandline/inspect/\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Docker Inspect</strong></a>: The Docker CLI provides the <code class=\"language-text\">docker inspect</code> command to view detailed information about an image, including its layers and filesystem changes. Although it doesn't provide interactive exploration, it's useful for inspecting image metadata.</li>\n<li><strong><a href=\"https://github.com/containers/skopeo\" target=\"_blank\" rel=\"noopener noreferrer\">Skopeo Inspect</a></strong>: Skopeo is a powerful tool that can inspect and copy container images between different registries. Use the <code class=\"language-text\">skopeo inspect</code> command to display detailed information about an image, helping you identify the layer containing your desired file.</li>\n<li><strong><a href=\"https://github.com/wagoodman/dive\" target=\"_blank\" rel=\"noopener noreferrer\">Dive</a></strong>: Dive is an image analysis tool that helps you find layers and gives a separate size of each layer and a list of files with size. Using Dive, you can easily discover ways to optimize the image. It is written in the Go language and is a tool for image analysis which you can use with Docker Desktop.</li>\n<li><strong><a href=\"https://explore.ggcr.dev/?image=raesene%2Falpine-containertools:latest\" target=\"_blank\" rel=\"noopener noreferrer\">Using explore.ggcr.dev</a></strong>: For a web-based interface to explore container image layers, explore.ggcr.dev is a fantastic option. This web tool allows you to input the container image's details and provides an interactive interface to navigate through the layers and locate the desired file. By visually exploring the layers, you can gain valuable insights into the image's structure and easily find the necessary files or configurations.</li>\n</ul>\n<h2 id=\"-conclusion\" style=\"position:relative;\"><a href=\"#-conclusion\" aria-label=\" conclusion permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>ğŸ Conclusion</h2>\n<p>Container registries empower developers to fetch individual layers efficiently, significantly reducing download times and resource consumption. By exploring the technical aspects of layer retrieval and embracing digest-based fetching, you ensure the integrity and accuracy of your container images.</p>\n<p>Implementing caching mechanisms and exploring various tools like Dive, Docker Inspect, and Skopeo further enhance your container workflow and enable you to make the most of container registries' potential.</p>\n<p><strong><em>Until next time, ã¤ã¥ã ğŸ‰</em></strong></p>\n<p><br><br></p>\n<blockquote>\n<p>ğŸ’¡ Thank you for Reading !! ğŸ™ŒğŸ»ğŸ˜ğŸ“ƒ, see you in the next blog.ğŸ¤˜  <strong><em>Until next time ğŸ‰</em></strong></p>\n</blockquote>\n<p>ğŸš€ Thank you for sticking up till the end. If you have any questions/feedback regarding this blog feel free to connect with me:</p>\n<p><strong>â™»ï¸ LinkedIn:</strong> <a href=\"https://www.linkedin.com/in/rajhi-saif/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.linkedin.com/in/rajhi-saif/</a></p>\n<p><strong>â™»ï¸ X/Twitter:</strong> <a href=\"https://x.com/rajhisaifeddine\" target=\"_blank\" rel=\"noopener noreferrer\">https://x.com/rajhisaifeddine</a></p>\n<p><strong>The end âœŒğŸ»</strong></p>\n<h1 align=\"center\">ğŸ”° Keep Learning !! Keep Sharing !! ğŸ”°</h1>\n<p><strong>ğŸ“… Stay updated</strong></p>\n<p>Subscribe to our newsletter for more insights on AWS cloud computing and containers.</p>"}}},"staticQueryHashes":["1271460761","1321585977"],"slicesMap":{}}